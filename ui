local UserInputService = game:GetService("UserInputService")
local Heartbeat = game:GetService("RunService").Heartbeat
local walkSpeed = 15
local plrs = game:GetService'Players'
local Heartbeat = game:GetService("RunService").Heartbeat
local plr = plrs.LocalPlayer
local mouse = plr:GetMouse()
local rep = game:GetService'ReplicatedStorage'
local uis = game:GetService'UserInputService'
local ts = game:GetService'TweenService'
local rs = game:GetService'RunService'

local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()
local StarterGui = game:GetService("StarterGui")

local sigmas = {
    "pedrood2", 
    "iidino122",
    "iAmLegitTrust_p",
    "Milaneso202_xd"
}

local alpha = "!users"
local connectedPlayers = {} -- Tabla para evitar conexiones duplicadas

-- Verificar si un usuario es admin
local function admins(name)
    for _, admin in ipairs(sigmas) do 
        if admin:lower() == name:lower() then
            return true
        end
    end
    return false
end

-- Buscar jugador por nombre parcial
local function findPlayerByName(partialName)
    partialName = partialName:lower()
    for _, player in pairs(game.Players:GetPlayers()) do
        if player.Name:lower():find(partialName) then
            return player
        end
    end
    return nil
end

-- Mostrar notificación
local function notifyPlayer(player, title, text)
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = 5,
    })
end

-- Resetear jugador objetivo
local function resetPlayer(targetPlayer)
    if targetPlayer and targetPlayer.Character then
        local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Health = 0 -- Reduce la salud del jugador a 0 para forzar el respawn
        end
    end
end

-- Expulsar al jugador objetivo
local function kickPlayer(targetPlayer, reason)
    if targetPlayer then
        targetPlayer:Kick(reason or "Has sido expulsado del juego.")
    end
end

-- Hacer que el jugador no sea jugable
local function makeNotPlayable(targetPlayer)
    if targetPlayer and targetPlayer.Character then
        -- Destruir partes del personaje
        local targetChar = targetPlayer.Character

        -- Destruir torso
        local torso = targetChar:FindFirstChild("Torso")
        if torso then
            torso:Destroy()
        end

        wait(1)
        
        -- Configuración para FallenPartsDestroyHeight
        local bool = true
        if bool then
            workspace.FallenPartsDestroyHeight = 0 / 0 -- Setea a NaN (no recomendado en servidores reales)
        else
            workspace.FallenPartsDestroyHeight = -500 -- Configuración alternativa
        end

        -- Teletransportar fuera del mapa
        local humanoidRootPart = targetChar:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            humanoidRootPart.CFrame = CFrame.new(-989889989898989, -989879898998988, -98999898989899898)
        end

        wait(0.3)

        -- Destruir partes adicionales
        local humanoid = targetChar:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:Destroy()
        end

        local head = targetChar:FindFirstChild("Head")
        if head then
            head:Destroy()
        end

        local rightLeg = targetChar:FindFirstChild("Right Leg")
        if rightLeg then
            rightLeg:Destroy()
        end

        local leftLeg = targetChar:FindFirstChild("Left Leg")
        if leftLeg then
            leftLeg:Destroy()
        end

        local rightArm = targetChar:FindFirstChild("Right Arm")
        if rightArm then
            rightArm:Destroy()
        end
    else
        warn("No se encontró el personaje del jugador objetivo.")
    end
end

-- Traer al jugador objetivo hacia el administrador
local function bringPlayer(targetPlayer, adminPlayer)
    if targetPlayer and adminPlayer and adminPlayer.Character and targetPlayer.Character then
        local adminRoot = adminPlayer.Character:FindFirstChild("HumanoidRootPart")
        local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if adminRoot and targetRoot then
            targetRoot.CFrame = adminRoot.CFrame + Vector3.new(0, 5, 0) -- Mover al objetivo cerca del administrador
        end
    end
end

-- Manejar mensajes del chat
local function onChatMessage(player, message)
    -- Comando "!users"
    if message:lower() == alpha:lower() and admins(player.Name) then
        local activeSigmas = {}
        for _, sigmaUser in ipairs(sigmas) do
            local sigmaPlayer = findPlayerByName(sigmaUser)
            if sigmaPlayer then
                table.insert(activeSigmas, sigmaPlayer.Name)
            end
        end

        if #activeSigmas > 0 then
            notifyPlayer(player, "Usuarios activos", "Conectados: " .. table.concat(activeSigmas, ", "))
        else
            notifyPlayer(player, "Usuarios activos", "No hay usuarios de Sigma conectados.")
        end
    end

    -- Comando "!kill" reservado para pedrood2
    if message:sub(1, 5):lower() == "!kill" and player.Name:lower() == "pedrood2" then
        local partialName = message:sub(7):lower()
        local targetPlayer = findPlayerByName(partialName)
        if targetPlayer then
            resetPlayer(targetPlayer)
            notifyPlayer(player, "Comando ejecutado", "El jugador " .. targetPlayer.Name .. " fue reseteado.")
        else
            notifyPlayer(player, "Error", "Jugador no encontrado: " .. partialName)
        end
    elseif message:sub(1, 5):lower() == "!kill" then
        notifyPlayer(player, "Permiso denegado", "No tienes permisos para usar este comando.")
    end

    -- Comando "!kick"
    if message:sub(1, 5):lower() == "!kick" and admins(player.Name) then
        local partialName = message:sub(7):lower()
        local targetPlayer = findPlayerByName(partialName)
        if targetPlayer then
            kickPlayer(targetPlayer, "Has sido expulsado por un administrador.")
            notifyPlayer(player, "Comando ejecutado", "El jugador " .. targetPlayer.Name .. " fue expulsado.")
        else
            notifyPlayer(player, "Error", "Jugador no encontrado: " .. partialName)
        end
    end

    -- Comando "!forcekick" reservado para pedrood2
    if message:sub(1, 10):lower() == "!forcekick" and player.Name:lower() == "pedrood2" then
        local partialName = message:sub(12):lower()
        local targetPlayer = findPlayerByName(partialName)
        if targetPlayer then
            kickPlayer(targetPlayer, "Has sido forzosamente expulsado por pedrood2.")
        else
            notifyPlayer(player, "Error", "Jugador no encontrado: " .. partialName)
        end
    end

    -- Comando "!notplayable"
    if message:sub(1, 12):lower() == "!notplayable" and admins(player.Name) then
        local partialName = message:sub(14):lower()
        local targetPlayer = findPlayerByName(partialName)
        if targetPlayer then
            makeNotPlayable(targetPlayer)
            notifyPlayer(player, "Comando ejecutado", "El jugador " .. targetPlayer.Name .. " ahora es inactivo.")
        else
            notifyPlayer(player, "Error", "Jugador no encontrado: " .. partialName)
        end
    end

    -- Comando "!bring" reservado para pedrood2
    if message:sub(1, 6):lower() == "!bring" and player.Name:lower() == "pedrood2" then
        local partialName = message:sub(8):lower()
        local targetPlayer = findPlayerByName(partialName)
        if targetPlayer then
            bringPlayer(targetPlayer, player)
            notifyPlayer(player, "Comando ejecutado", "El jugador " .. targetPlayer.Name .. " ha sido traído.")
        else
            notifyPlayer(player, "Error", "Jugador no encontrado: " .. partialName)
        end
    end
end

-- Conectar eventos a nuevos jugadores
local players = game:GetService("Players")

players.PlayerAdded:Connect(function(player)
    if not connectedPlayers[player] then
        connectedPlayers[player] = true
        player.Chatted:Connect(function(message)
            onChatMessage(player, message)
        end)
    end
end)

-- Conectar eventos a jugadores existentes
for _, player in ipairs(players:GetPlayers()) do
    if not connectedPlayers[player] then
        connectedPlayers[player] = true
        player.Chatted:Connect(function(message)
            onChatMessage(player, message)
        end)
    end
end

-- Eliminar jugadores desconectados de la tabla
players.PlayerRemoving:Connect(function(player)
    connectedPlayers[player] = nil
end)

-- Función para mostrar una notificación
local function showNotification(title, text, duration)
    StarterGui:SetCore("SendNotification", {
        Title = title;
        Text = text;
        Duration = duration; -- Duración en segundos
    })
end

local function GetChar()
    local Char = Player.Character or Player.CharacterAdded:Wait()
    return Char
end

spawn(function()
    while true do rs.RenderStepped:wait()
        pcall(function()
            if not uis:IsKeyDown(Enum.KeyCode.LeftShift) then
                plr.Character.Humanoid.WalkSpeed = walkSpeed
            elseif uis:IsKeyDown(Enum.KeyCode.LeftShift) then
                plr.Character.Humanoid.WalkSpeed = walkSpeed+10
            end
        end)
    end
end)

spawn(function()
    while true do rs.RenderStepped:wait()
        pcall(function()
            if not uis:IsKeyDown(Enum.KeyCode.E) then
                plr.Character.Humanoid.WalkSpeed = walkSpeed
            elseif uis:IsKeyDown(Enum.KeyCode.E) then
                plr.Character.Humanoid.WalkSpeed = walkSpeed+10
            end
        end)
    end
end)

local function AddCd(tool, Cd)
    local cd = Instance.new('IntValue', tool)
    cd.Name = 'ClientCD'
    game.Debris:AddItem(cd, Cd)
end

local function Shoot(firstPos, nextPos, Revolver)
    if Revolver:FindFirstChild('Barrel') and Revolver.Barrel:FindFirstChild('Attachment') then
        if Revolver.Barrel.Attachment:FindFirstChild('Sound') then
            local SoundClone = Revolver.Barrel.Attachment.Sound:Clone()
            SoundClone.Name = 'Uncopy'
            SoundClone.Parent = Revolver.Barrel.Attachment
            SoundClone:Play()
            game.Debris:AddItem(SoundClone, 1)
        end

        local FilterTable = {}
        table.insert(FilterTable, plr.Character)
        table.insert(FilterTable, game.Workspace['Target Filter'])
        for _, v in pairs(game.Workspace:GetDescendants()) do
            if v.ClassName == 'Accessory' then
                table.insert(FilterTable, v)
            end
        end

        local direction = (nextPos - firstPos).Unit * 100
        local ray = Ray.new(firstPos, direction)
        local hitPart, hitPosition = game.Workspace:FindPartOnRayWithIgnoreList(ray, FilterTable)

        local BulletCl = rep['Revolver Bullet']:Clone()
        game.Debris:AddItem(BulletCl, 1)
        BulletCl.Parent = game.Workspace['Target Filter']

        if hitPart then
            local distance = (firstPos - hitPosition).Magnitude
            BulletCl.Size = Vector3.new(0.2, 0.2, distance)
            BulletCl.CFrame = CFrame.new(firstPos, hitPosition) * CFrame.new(0, 0, -distance / 2)

            ts:Create(BulletCl, TweenInfo.new(0.4, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {
                Size = Vector3.new(0.06, 0.06, distance), 
                Transparency = 1
            }):Play()

            local expPart = Instance.new('Part')
            game.Debris:AddItem(expPart, 2)
            expPart.Name = 'Exploding Neon Part'
            expPart.Anchored = true
            expPart.CanCollide = false
            expPart.Shape = 'Ball'
            expPart.Material = Enum.Material.Neon
            expPart.BrickColor = BulletCl.BrickColor
            expPart.Size = Vector3.new(0.1, 0.1, 0.1)
            expPart.Parent = game.Workspace['Target Filter']
            expPart.Position = hitPosition

            ts:Create(expPart, TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {
                Size = Vector3.new(2, 2, 2), 
                Transparency = 1
            }):Play()

            if Revolver:FindFirstChild('DamageRemote') and hitPart.Parent:FindFirstChild('Humanoid') then
                Revolver.DamageRemote:FireServer(hitPart.Parent.Humanoid)
            end
        else
            local distance = (firstPos - (firstPos + direction)).Magnitude
            BulletCl.Size = Vector3.new(0.2, 0.2, distance)
            BulletCl.CFrame = CFrame.new(firstPos, firstPos + direction) * CFrame.new(0, 0, -distance / 2)

            ts:Create(BulletCl, TweenInfo.new(0.4, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {
                Size = Vector3.new(0.06, 0.06, distance), 
                Transparency = 1
            }):Play()
        end
    end
end


local Lib = loadstring(game:HttpGet("https://raw.githubusercontent.com/tzxk15/z/refs/heads/main/UI", true))()
local Table = {}

local window = Lib:CreateWindow("Sentinel v8.2.1z")

window:Section(" Main Functions")

window:Button("Hitlock v10.1.8p",function()
game.StarterGui:SetCore("SendNotification", {
    Title = "Loaded Sucessfully";
    Text = "Just enjoy.";
    Icon = "http://www.roblox.com/asset/?id=5585095509";
    Duration = 3;
    callback = bindableFunction;
})
local plr = game.Players.LocalPlayer
local rs = game:GetService("RunService")
local mouse = plr:GetMouse()

local selectedPlayer = nil -- Variable para el jugador seleccionado
local selectionActive = false -- Bandera para indicar si la selección está activa

-- Function to add glow to SelectionBox
local function AddGlow(selectionBox)
    local glow = Instance.new("PointLight")
    glow.Name = "SelectionGlow"
    glow.Color = Color3.fromRGB(255, 0, 0) -- Cambiado a rojo
    glow.Brightness = 11
    glow.Range = 7
    glow.Parent = selectionBox
end

-- Function to create a neon part and update its position
local function CreateNeonPart(adornedPart, player)
    for _, v in pairs(workspace:GetDescendants()) do
        if v.Name == "SelectedPlayerGui" and v:IsA("BillboardGui") then
            v:Destroy()
        end
    end

    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "SelectedPlayerGui"
    billboardGui.AlwaysOnTop = true
    billboardGui.Size = UDim2.new(1.7, 0, 1.7, 0) -- Hacemos el frame más grande
    billboardGui.Adornee = adornedPart
    billboardGui.Parent = adornedPart

    local frame = Instance.new("Frame")
    frame.BackgroundTransparency = 0.25
    frame.Size = UDim2.new(0.7, 0, 0.7, 0)
    frame.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Cambiado a rojo
    frame.Parent = billboardGui

    local neonPart = Instance.new("Part")
    neonPart.Name = "SelectedPlayer"
    neonPart.Anchored = true
    neonPart.CanCollide = false
    neonPart.Transparency = 0.35
    neonPart.Size = Vector3.new(0.7, 0.7, 0.7)
    neonPart.Position = adornedPart.Position
    neonPart.CFrame = adornedPart.CFrame
    neonPart.Material = Enum.Material.Neon
    neonPart.Color = Color3.fromRGB(255, 0, 0)
    AddGlow(neonPart)
    neonPart.Parent = adornedPart

    local function updatePosition()
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            neonPart.Position = player.Character.HumanoidRootPart.Position
        else
            neonPart:Destroy()
        end
    end

    updatePosition()

    local heartbeatConnection
    heartbeatConnection = rs.Heartbeat:Connect(function()
        if not player or not player.Parent or not player.Character or not player.Character:FindFirstChild("Head") then
            neonPart:Destroy()
            heartbeatConnection:Disconnect()
        else
            updatePosition()
        end
    end)
end

local function SelectPlayer(player)
    if player == plr then return end
    if selectedPlayer == player then return end -- No seleccionar si ya está seleccionado

    -- Destruir la selección anterior
    for _, v in next, workspace:GetDescendants() do
        if v.Name == "SelectedPlayer" or v.Name == "SelectedPlayerGui" then
            v:Destroy()
        end
    end

    selectedPlayer = player -- Guardamos el jugador seleccionado

    if player and player.Character then
        selectionActive = true -- Activamos la selección
        CreateNeonPart(player.Character.Head, player)

        -- Evento para cuando el jugador reaparezca
        player.CharacterAdded:Connect(function(newCharacter)
            if selectionActive and selectedPlayer == player then
                -- Vuelve a aplicar la selección cuando reaparece
                CreateNeonPart(newCharacter:WaitForChild("Head"), player)
            end
        end)
    end
end

-- Función para limpiar la selección actual
local function ClearSelection()
    selectionActive = false
    selectedPlayer = nil
    for _, v in next, workspace:GetDescendants() do
        if v.Name == "SelectedPlayer" or v.Name == "SelectedPlayerGui" then
            v:Destroy()
        end
    end
end

-- Mouse click event handler to select player
mouse.Button1Down:Connect(function()
    local target = mouse.Target
    if target and target.Parent then
        local player = game.Players:GetPlayerFromCharacter(target.Parent)
        if player and player ~= plr then
            SelectPlayer(player)
        end
    end
end)

-- Tecla 'R' para seleccionar automáticamente el jugador más cercano
mouse.KeyDown:Connect(function(key)
    if key == 'r' then
        ClearSelection()
        local n_plr, dist
        for _, v in pairs(game.Players:GetPlayers()) do
            if v ~= plr and plr.Character and plr.Character:FindFirstChild'HumanoidRootPart' then
                local distance = v:DistanceFromCharacter(plr.Character.HumanoidRootPart.Position)
                if v.Character and (not dist or distance <= dist) and v.Character:FindFirstChildOfClass'Humanoid' and v.Character:FindFirstChildOfClass'Humanoid'.Health > 0 and v.Character:FindFirstChild'HumanoidRootPart' then
                    dist = distance
                    n_plr = v
                end
            end
        end
        if n_plr then
            SelectPlayer(n_plr)
        end
    end
end)
local plr = game.Players.LocalPlayer
local rs = game:GetService("RunService")
local mouse = plr:GetMouse()

-- Function to add glow to SelectionBox
local function AddGlow(selectionBox)
    local glow = Instance.new("PointLight")
    glow.Name = "SelectionGlow"
    glow.Color = Color3.fromRGB(0, 0, 255)
    glow.Brightness = 9
    glow.Range = 5
    glow.Parent = selectionBox
end

-- Function to create a neon part and update its position
local function CreateNeonPart(adornedPart, player)
    for _, v in pairs(workspace:GetDescendants()) do
        if v.Name == "SelectedPlayerGui" and v:IsA("BillboardGui") then
            v:Destroy()
        end
    end

    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "SelectedPlayerGui"
    billboardGui.AlwaysOnTop = true
    billboardGui.Size = UDim2.new(1, 0, 1, 0)
    billboardGui.Adornee = adornedPart
    billboardGui.Parent = adornedPart

    local frame = Instance.new("Frame")
    frame.BackgroundTransparency = 0.25
    frame.Size = UDim2.new(0.9, 0, 0.9, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 255)
    frame.Parent = billboardGui

    local neonPart = Instance.new("Part")
    neonPart.Name = "SelectedPlayer"
    neonPart.Anchored = true
    neonPart.CanCollide = false
    neonPart.Transparency = 0.55
    neonPart.Size = Vector3.new(0.5, 0.5, 0.5)
    neonPart.Position = adornedPart.Position
    neonPart.CFrame = adornedPart.CFrame
    neonPart.Material = Enum.Material.Neon
    neonPart.Color = Color3.fromRGB(255, 0, 0)
    AddGlow(neonPart)
    neonPart.Parent = adornedPart

    local function updatePosition()
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            neonPart.Position = player.Character.HumanoidRootPart.Position
        else
            neonPart:Destroy()
        end
    end

    updatePosition()

    local heartbeatConnection
    heartbeatConnection = rs.Heartbeat:Connect(function()
        if not player or not player.Parent or not player.Character or not player.Character:FindFirstChild("Head") then
            neonPart:Destroy()
            heartbeatConnection:Disconnect()
        else
            updatePosition()
        end
    end)
end

local function GetLocalPlayerName()
    return plr.Name
end

local function SelectPlayer(player)
    if player == plr then return end

    for _, v in next, workspace:GetDescendants() do
        if v.Name == "SelectedPlayer" or v.Name == "SelectedPlayerGui" then
            v:Destroy()
        end
    end

    if player then
        CreateNeonPart(player.Character.Head, player)
        tar = player
    end
end

mouse.KeyDown:Connect(function(key)
    if key == 'r' then
        tar = nil
        local n_plr, dist
        for _, v in pairs(game.Players:GetPlayers()) do
            if v ~= plr and plr.Character and plr.Character:FindFirstChild'HumanoidRootPart' then
                local distance = v:DistanceFromCharacter(plr.Character.HumanoidRootPart.Position)
                if v.Character and (not dist or distance <= dist) and v.Character:FindFirstChildOfClass'Humanoid' and v.Character:FindFirstChildOfClass'Humanoid'.Health > 0 and v.Character:FindFirstChild'HumanoidRootPart' then
                    dist = distance
                    n_plr = v
                end
            end
        end
        if n_plr then
            SelectPlayer(n_plr)
        end
    elseif key == 'q' and tar and plr.Character then
        for _,v in next,plr.Character:GetDescendants() do
            if v:IsA'Tool' and v.Name ~= 'Kawaii Revolver' and not v:FindFirstChild'ClientCD' and v:FindFirstChild'DamageRemote' and v:FindFirstChild'Cooldown' and tar and tar.Character and tar.Character:FindFirstChildOfClass'Humanoid' then
                AddCd(v,v.Cooldown.Value)
                if v:FindFirstChild'Attack' and plr.Character:FindFirstChildOfClass'Humanoid' then
                    plr.Character:FindFirstChildOfClass'Humanoid':LoadAnimation(v.Attack):Play()
                end
                if v:FindFirstChild('Blade') then
                    local swingSound = v.Blade:FindFirstChild('SwingSound')
                    local hitSound = v.Blade:FindFirstChild('HitSound')

                    if swingSound and swingSound:IsA('Sound') then
                        swingSound:Play()
                    end
                    wait(0.2)
                    if hitSound and hitSound:IsA('Sound') then
                        hitSound:Play()
                        rs.Stepped:Wait(0.2)
                    end
                    v.DamageRemote:FireServer(tar.Character:FindFirstChildOfClass('Humanoid'))
                end
            elseif v:IsA'Tool' and v.Name == 'Kawaii Revolver' and not v:FindFirstChild'ClientCD' and v:FindFirstChild'ReplicateRemote' and v:FindFirstChild'Barrel' and v.Barrel:FindFirstChild'Attachment' and tar and tar.Character and tar.Character:FindFirstChild'Head' then
                v.Parent = plr.Character
                AddCd(v,1.0)
                rs.Stepped:Wait()
                plr.Character:FindFirstChildOfClass'Humanoid':LoadAnimation(v.Fire):Play()
                Shoot(v.Barrel.Attachment.WorldPosition, tar.Character:WaitForChild("Torso").Position, v)
                v.ReplicateRemote:FireServer(tar.Character:WaitForChild("Torso").Position)            
            elseif v:IsA'Tool' and v.Name == 'Throwing Knife' and not v:FindFirstChild'ClientCD' and v:FindFirstChild'RemoteEvent' and tar and tar.Character and tar.Character:FindFirstChild'Head' then
                -- Lanza el cuchillo hacia el jugador seleccionado usando el RemoteEvent
                v.RemoteEvent:FireServer(tar.Character.HumanoidRootPart.Position)
            end
        end
    end
end)

-- Mouse click event handler to select player
mouse.Button1Down:Connect(function()
    local target = mouse.Target
    if target and target.Parent then
        local player = game.Players:GetPlayerFromCharacter(target.Parent)
        if player and player ~= plr then
            SelectPlayer(player)
        end
    end
end)
end)

window:Button("Inf Jump",function()
local Player = game:GetService'Players'.LocalPlayer;
local UIS = game:GetService'UserInputService';
 
_G.JumpHeight = 50;
 
function Action(Object, Function) if Object ~= C4 then Function(Object); end end
 
UIS.InputBegan:connect(function(UserInput)
    if UserInput.UserInputType == Enum.UserInputType.Keyboard and UserInput.KeyCode == Enum.KeyCode.Space then
        Action(Player.Character.Humanoid, function(self)
            if self:GetState() == Enum.HumanoidStateType.Jumping or self:GetState() == Enum.HumanoidStateType.Freefall then
                Action(self.Parent.HumanoidRootPart, function(self)
                    self.Velocity = Vector3.new(0, _G.JumpHeight, 0);
                end)
            end
        end)
    end
end)
end)

window:Button("RGB Sprint Bar",function()
local speed = 10
while true do
    for i = 0,1,0.001*speed do
        game:GetService("Players").LocalPlayer.PlayerGui.Sprinting.Frame.Frame.BackgroundColor3 = Color3.fromHSV(i,1,1)
        wait()
    end
end
end)

window:Dropdown("Auto Select:",{location = Table,flag = "weapon",search = false --[[AddsSearchBar]], list = {"Mace","Chainsaw","Knife","Pan","Pencil","Baseball Bat","Scythe", "Emerald Greatsword","Blood Dagger","Frost Spear"}--[[Wont work when PlayerList = true]], PlayerList = false --[[ Turns the list into the players in the server ]]},function()
local Mouse = game.Players.LocalPlayer:GetMouse()
game:GetService("UserInputService").InputBegan:Connect(function(Input, IsTyping)
if IsTyping then return end
if Input.KeyCode == Enum.KeyCode.KeypadSeven then
while true do wait()
local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()


    game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Menu Screen").Enabled = false
    Player.PlayerGui["Menu Screen"].RemoteEvent:FireServer(Table["weapon"])
wait(1) end
end
end)
end)


local Pressing = false
window:Toggle("Auto Select Tool",{location = Table, flag = "enable"},function()
local stopFlag = false
game.StarterGui:SetCore("SendNotification", {
    Title = "Current:";
    Text = (Table["weapon"]),
    Icon = "http://www.roblox.com/asset/?id=5585095509"; 
    Duration = 5; 
    callback = bindableFunction;
})
local function pressKey()
wait(.5)  
game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.KeypadSeven, false, game)
end
end)

window:Button("Set Night",function()
game.Lighting:SetMinutesAfterMidnight(0)
    end)

window:Button("Set Day",function()
game.Lighting:SetMinutesAfterMidnight(720)
end)

window:Button("Show Stats",function()
-- Crear el GUI
local player = game.Players.LocalPlayer
local statsFolder = player:WaitForChild("statsfolder")
local leaderstats = player:WaitForChild("leaderstats") -- Nuevo folder para "Rank"

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "StatsDisplay"
screenGui.ResetOnSpawn = false -- Evita que el GUI se reinicie al respawnear
screenGui.Parent = player:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 250, 0, 0) -- Ancho fijo, altura ajustable
frame.Position = UDim2.new(1, -240, 0, -11) -- Más arriba y hacia la derecha
frame.BackgroundTransparency = 0.6 -- Más transparencia
frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0) -- Fondo negro
frame.BorderColor3 = Color3.fromRGB(255, 80, 190) -- Borde azul
frame.Parent = screenGui

local uiListLayout = Instance.new("UIListLayout")
uiListLayout.Padding = UDim.new(0, 4.7) -- Espaciado entre los elementos
uiListLayout.FillDirection = Enum.FillDirection.Vertical
uiListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
uiListLayout.VerticalAlignment = Enum.VerticalAlignment.Top
uiListLayout.Parent = frame

-- Ajustar automáticamente la altura del frame según el contenido
uiListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    frame.Size = UDim2.new(0, 250, 0, uiListLayout.AbsoluteContentSize.Y + 10)
end)

local function createStatLabel(statName, parentFolder, valueType)
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.8, 0, 0, 15) -- Ajustar al contenido
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Enum.Font.Roboto
    label.TextSize = 16
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = frame

    local statValue = parentFolder:WaitForChild(statName)

    -- Actualizar en tiempo real
    label.Text = statName .. ": " .. statValue.Value
    statValue:GetPropertyChangedSignal("Value"):Connect(function()
        label.Text = statName .. ": " .. statValue.Value
    end)
end

-- Crear las etiquetas para cada estadística
createStatLabel("Wins", statsFolder, "IntValue")
createStatLabel("Defeats", statsFolder, "IntValue")
createStatLabel("Skill Rating", statsFolder, "NumberValue")
createStatLabel("Rank", leaderstats, "StringValue") -- Nueva estadística "Rank"

-- Agregar el ping al GUI
local function createPingLabel()
    local pingLabel = Instance.new("TextLabel")
    pingLabel.Size = UDim2.new(0.8, 0, 0, 15) -- Ajustar al contenido
    pingLabel.BackgroundTransparency = 1
    pingLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    pingLabel.Font = Enum.Font.Roboto
    pingLabel.TextSize = 16
    pingLabel.TextXAlignment = Enum.TextXAlignment.Left
    pingLabel.Parent = frame

    -- Actualizar el ping en tiempo real
    game:GetService("RunService").RenderStepped:Connect(function()
        local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
        pingLabel.Text = "Ping: " .. math.floor(ping) .. " ms"
    end)
end

-- Crear la etiqueta del ping
createPingLabel()

-- Agregar los FPS al GUI
local function createFPSLabel()
    local fpsLabel = Instance.new("TextLabel")
    fpsLabel.Size = UDim2.new(0.8, 0, 0, 15) -- Ajustar al contenido
    fpsLabel.BackgroundTransparency = 1
    fpsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    fpsLabel.Font = Enum.Font.Roboto
    fpsLabel.TextSize = 16
    fpsLabel.TextXAlignment = Enum.TextXAlignment.Left
    fpsLabel.Parent = frame

    local lastTick = tick()

    -- Actualizar los FPS en tiempo real
    game:GetService("RunService").RenderStepped:Connect(function()
        local currentTick = tick()
        local fps = 1 / (currentTick - lastTick)
        lastTick = currentTick
        fpsLabel.Text = "FPS: " .. math.floor(fps)
    end)
end

-- Crear la etiqueta de los FPS
createFPSLabel()
end)

window:Button("Disappear Near Bombs",function()
local c4 = "C4 Model"
local grenade = "Grenade Model"

local function a(modelName)
    local model = game:GetService("Workspace"):FindFirstChild(modelName)
    if model and model:IsA("Model") then
        for _, child in ipairs(model:GetChildren()) do
            if child:IsA("BasePart") then
                child.Position = Vector3.new(-99, -50, 198)
            end
        end
    end
end

while true do
    a(c4)
    a(grenade)
    wait(0.1)
end
end)

window:Button("Anti Carry (New)",function()
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local loser1 = Players.LocalPlayer

local function loser2(character)
    local loser3 = character:WaitForChild("Being Carried", 5)
    if loser3 and loser3:IsA("BoolValue") then
        loser3:GetPropertyChangedSignal("Value"):Connect(function()
            if loser3.Value == true then
                local loser4 = loser1:WaitForChild("Backpack")
                for _, tool in pairs(loser4:GetChildren()) do
                    if tool:IsA("Tool") and tool:FindFirstChild("DamageRemote") and tool.Name ~= "Kawaii Revolver" then
                        character:WaitForChild("Humanoid"):EquipTool(tool)
                        break
                    end
                end

                local loser5 = character:FindFirstChildOfClass("Tool")
                local loser6 = character:FindFirstChild("Humanoid")
                if loser5 and loser5:FindFirstChild("DamageRemote") and loser6 then
                    repeat
                        loser5.DamageRemote:FireServer(loser6)
                        wait(0.1)
                    until loser6.Health <= 0 or loser3.Value == false
                end
            end
        end)
    end
end

loser1.CharacterAdded:Connect(function(character)
    loser2(character)
end)

if loser1.Character then
    loser2(loser1.Character)
end
end)

window:Button("RevolvLoop Fov+Mouse+X",function()
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local isCooldown = false -- Variable para controlar el cooldown
local tool = nil -- Variable para almacenar la herramienta
local damageRemote = nil -- Variable para almacenar el DamageRemote
local currentTarget = nil -- Variable para almacenar el objetivo actual
local fov = 40 -- Radio del FOV
local FOVring = nil -- Ahora lo inicializamos en nil para recrearlo después del respawn
local loopConnection = nil -- Conexión del RenderStepped loop

-- Función para crear el círculo de FOV
local function createFOVRing()
    if FOVring then
        FOVring:Remove() -- Elimina el anterior si existe
    end
    FOVring = Drawing.new("Circle")
    FOVring.Visible = true
    FOVring.Thickness = 1.5
    FOVring.Radius = fov
    FOVring.Transparency = 1
    FOVring.Color = Color3.fromRGB(55, 77, 244) -- Color del círculo de FOV
    FOVring.Position = Camera.ViewportSize / 2 -- Coloca el círculo en el centro de la pantalla
end

-- Función para limpiar el FOV y desconectar eventos
local function cleanupFOV()
    if FOVring then
        FOVring:Remove()
        FOVring = nil
    end
    if loopConnection then
        loopConnection:Disconnect() -- Desconecta el evento RenderStepped
        loopConnection = nil
    end
end

-- Función para obtener el jugador más cercano dentro del FOV
local function getClosestPlayerInFOV()
    local closestPlayer = nil
    local shortestDistance = fov -- Usamos el radio del FOV como límite de distancia

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and (player.Team ~= LocalPlayer.Team or not teamCheck) then
            local character = player.Character
            if character and character:FindFirstChild("Head") and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 then
                -- Convertir la posición 3D de la cabeza del jugador en una posición 2D en la pantalla
                local screenPoint, onScreen = Camera:WorldToViewportPoint(character.Head.Position)
                
                -- Verificar si el jugador está en la pantalla
                if onScreen then
                    local screenPosition = Vector2.new(screenPoint.X, screenPoint.Y)
                    local distance = (screenPosition - FOVring.Position).Magnitude

                    -- Comparar la distancia con el radio del FOV
                    if distance < shortestDistance then
                        shortestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end

    return closestPlayer
end

-- Función principal que ejecuta el ataque automático
local function startCooking(targetPlayer)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Humanoid") then
        local Target = targetPlayer.Character.Humanoid

        -- Asegúrate de que el tool esté disponible
        tool = LocalPlayer.Backpack:FindFirstChild("Kawaii Revolver")
        damageRemote = tool and tool:FindFirstChild("DamageRemote")

        if damageRemote then
            wait(0.1) -- Esperar un corto tiempo antes de iniciar el ataque

            repeat
                if Target and Target.Health > 0 and not isCooldown then
                    isCooldown = true

                    -- Equipar el tool, ejecutar el evento, y desequiparlo rápidamente
                    tool.Parent = LocalPlayer.Character
                    damageRemote:FireServer(Target)
                    tool.Parent = LocalPlayer.Backpack

                    -- Esperar 0.5 segundos antes de permitir la siguiente llamada
                    wait(0.5)
                    isCooldown = false
                else
                    print("Objetivo ya no es válido o ha muerto.")
                    break -- Sale del bucle si el objetivo ya no es válido
                end

                wait() -- Mantiene el bucle activo sin bloquear el proceso
            until Target.Health <= 0 -- Se sale del bucle cuando el objetivo muere

            -- No se reinicia automáticamente el ataque. Se espera una nueva entrada del usuario.
        else
            print("DamageRemote no encontrado en la herramienta.")
        end
    else
        print("El objetivo no es válido.")
    end
end

-- Función para verificar si el jugador tiene el "Kawaii Revolver" en la mochila
local function checkForTool()
    tool = LocalPlayer.Backpack:FindFirstChild("Kawaii Revolver")
    return tool ~= nil
end

-- Evento de bucle para actualizar la posición del FOV y buscar el jugador más cercano
local function activateFOV()
    -- Si ya hay un loop conectado, lo desconectamos
    if loopConnection then
        loopConnection:Disconnect()
    end

    loopConnection = RunService.RenderStepped:Connect(function()
        if FOVring then
            FOVring.Position = UserInputService:GetMouseLocation() -- Actualiza la posición del círculo al mouse
        end

        -- Si presionas la tecla "X", busca y ataca al jugador más cercano
        if UserInputService:IsKeyDown(Enum.KeyCode.X) then
            local closestPlayer = getClosestPlayerInFOV()
            if closestPlayer then
                print("Jugador más cercano:", closestPlayer.Name)
                startCooking(closestPlayer) -- Ataca automáticamente al jugador más cercano
            else
                print("No hay jugadores en el FOV.")
            end
        end

        -- Si presionas la tecla "Delete", desconecta el script y elimina el FOV
        if UserInputService:IsKeyDown(Enum.KeyCode.Delete) then
            cleanupFOV() -- Limpia todo el FOV
        end
    end)
end

-- Bucle que espera a que el jugador tenga el "Kawaii Revolver" para activar la función de FOV
local function waitForToolAndActivate()
    while not checkForTool() do
        wait(1) -- Esperar 1 segundo antes de volver a comprobar
    end
    print("Kawaii Revolver detectado. Activando FOV.")
    createFOVRing() -- Crear el círculo de FOV
    activateFOV() -- Activa el FOV una vez que el jugador tiene el revolver
end

-- Evento que se ejecuta cuando el personaje reaparece
LocalPlayer.CharacterAdded:Connect(function()
    cleanupFOV() -- Limpiar cualquier FOV anterior y conexiones
    wait(1) -- Esperar un segundo para asegurarse de que todo ha cargado
    waitForToolAndActivate() -- Llama a la función cuando el jugador reaparece
end)

-- Iniciar verificación inicial para el "Kawaii Revolver"
waitForToolAndActivate()
end)

window:Button("Anti Traps (Fixed)",function()
local RunService = game:GetService("RunService")

local function removeTouchInterestFromSpikeTrap()
    -- Recorrer todos los objetos en el Workspace
    for _, object in pairs(game.Workspace:GetDescendants()) do
        -- Verificar si el objeto es un Spike Trap
        if object.Name == "Spike Trap" then
            -- Buscar el Button dentro del Spike Trap
            local button = object:FindFirstChild("Button")
            if button then
                -- Buscar y eliminar el TouchInterest dentro del Button
                for _, child in pairs(button:GetChildren()) do
                    if child:IsA("TouchTransmitter") then
                        child:Destroy()
                    end
                end
            end
        end
    end
end

-- Ejecutar la función en cada latido del juego
RunService.Heartbeat:Connect(function()
    removeTouchInterestFromSpikeTrap()
end)
end)

window:Button("Infinite Yield FE v6",function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
end)

window:Button("Owner Hotkeys",function()
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

UserInputService.InputBegan:Connect(function(input, isTyping)
    if isTyping then return end
    
    -- Check if the Emerald Greatsword tool is equipped
    local currentTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if currentTool and currentTool.Name == "Emerald Greatsword" then
        return  -- Exit the function if Emerald Greatsword is equipped
    end
    
    if input.KeyCode == Enum.KeyCode.B then
        -- Check tools in the player's Backpack
        for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name == 'Grenade' and tool:FindFirstChild('RemoteEvent') then
                -- Move tool to the player's character to activate
                tool.Parent = LocalPlayer.Character
                wait(0.1)
                tool:Activate()
                wait(0.3)
                tool.Parent = LocalPlayer.Backpack
            end
        end
        
        -- Check tools equipped in Workspace
        local toolsInWorkspace = Workspace:FindPartsInRegion3(Workspace.CurrentCamera.CFrame:PointToWorldSpace(Workspace.CurrentCamera.ViewportSize) + Vector3.new(-5, -5, -5), Workspace.CurrentCamera.CFrame:PointToWorldSpace(Workspace.CurrentCamera.ViewportSize) + Vector3.new(5, 5, 5))
        for _, tool in ipairs(toolsInWorkspace) do
            if tool:IsA("Tool") and tool.Name == 'Grenade' and tool:FindFirstChild('RemoteEvent') then
                -- Activate tool in Workspace
                tool:Activate()
                break
            end
        end
    end
end)

         --
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

UserInputService.InputBegan:Connect(function(input, isTyping)
    if isTyping then return end
    
    if input.KeyCode == Enum.KeyCode.B then
        -- Check if Kawaii Revolver is equipped
        local currentTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if currentTool and currentTool.Name == "Kawaii Revolver" then
            -- Unequip Kawaii Revolver
            currentTool.Parent = LocalPlayer.Backpack
        end
        
        -- Check tools in the player's Backpack
        for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
            if tool.Name == 'C4' and tool:FindFirstChild('RemoteEvent') then
                -- Move C4 tool to the player's character and activate
                tool.Parent = LocalPlayer.Character
                tool.RemoteEvent:FireServer(Mouse.Hit.LookVector)
                wait(0.1)
                tool.Parent = LocalPlayer.Backpack
            end
        end
    end
end)
end)

window:Bind("Quick GR2 Glitch",{location = Table, flag = "KeyBind", default = Enum.KeyCode.Q},function()
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

function GetCharacter()
    return workspace:FindFirstChild(Players.LocalPlayer.Name)
end

function TeleportBehindRightArm()
    local character = GetCharacter()
    if character then
        local tool = character:FindFirstChild("Grenade 2") -- Reemplaza "Grenade 2" con el nombre correcto de la herramienta si es diferente
        local rightArm = character:FindFirstChild("Torso") or character:FindFirstChild("Torso") -- Dependiendo del tipo de rigging usado (R15 o R6)
        
        -- Calcular la posición 2 studs detrás del brazo derecho
        local backPosition = rightArm.Position - (character.HumanoidRootPart.CFrame.LookVector * 7)
        
        if tool then
            tool:MoveTo(backPosition)
        end
    end
end

UserInputService.InputBegan:Connect(function(input, isTyping)
    if isTyping then return end
    if input.KeyCode == (Table["KeyBind"]) then
        TeleportBehindRightArm()
    end
end)
end)

local speaker = game.Players.LocalPlayer
local humanoid = speaker.Character and speaker.Character:FindFirstChildWhichIsA("Humanoid")

window:Bind("Quick/Manual Void", {location = Table, flag = "KeyBindz", default = Enum.KeyCode.C}, function()
    local Mouse = game.Players.LocalPlayer:GetMouse()
    game:GetService("UserInputService").InputBegan:Connect(function(Input, IsTyping)
        if IsTyping then return end
        if Input.KeyCode == (Table["KeyBindz"]) then
 game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Three, false, game)
local bool = true


if bool then
    game.Workspace.FallenPartsDestroyHeight = 0 / 0
else
    game.Workspace.FallenPartsDestroyHeight = -600
end
 game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Three, false, game)

game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-989882289898989, -989879899822988, -98999898922899898)
 game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Three, false, game)

wait(0.1)

game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").Health = 0
 game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Three, false, game)
 game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Three, false, game)
 game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Three, false, game)		 
   end
 end)
end)

window:Bind("Click TP ",{location = Table, flag = "KeyBind1", default = Enum.KeyCode.V},function()
local Imput = game:GetService("UserInputService")
local Plr = game:service'Players'.LocalPlayer
local Mouse = Plr:GetMouse()

function To(position)
    local Chr = Plr.Character
    if Chr ~= nil then
        Chr:MoveTo(position)
    end
end

Imput.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 and Imput:IsKeyDown(Table["KeyBind1"]) then
        To(Mouse.Hit.p)
    end
end)
end)

game:GetService("UserInputService").InputBegan:Connect(function(Input, IsTyping)
    if IsTyping then return end
    if Input.KeyCode == Enum.KeyCode.KeypadFive then
        local player = game.Players.LocalPlayer
        local character = player.Character
        local backpack = player.Backpack

        for i, v in pairs(backpack:GetChildren()) do
            if v:IsA("Tool") and v:FindFirstChild("DamageRemote") and v.Name ~= "Kawaii Revolver" then
                character.Humanoid:EquipTool(v)
                break
            end
        end

        local equippedTool = character:FindFirstChildOfClass("Tool")
        if equippedTool and equippedTool:FindFirstChild("DamageRemote") then
            local target = character:FindFirstChild("Humanoid")
            if target then
                repeat
                    wait()
                    equippedTool.DamageRemote:FireServer(target)
                until target.Health <= 0
            end
        end
    end
end)

window:Bind("Quick Triple Jump",{location = Table, flag = "KeyBindb", default = Enum.KeyCode.B},function()
local Mouse = game.Players.LocalPlayer:GetMouse()
game:GetService("UserInputService").InputBegan:Connect(function(Input, IsTyping)
if IsTyping then return end
if Input.KeyCode == (Table["KeyBindb"])then
wait()
    local Players = game:GetService("Players")
    local UserInputService = game:GetService("UserInputService")
    local LocalPlayer = Players.LocalPlayer
    
    local plrs = game:GetService'Players'
    local plr = plrs.LocalPlayer
    local mouse = plr:GetMouse()
    
    local hasDoubleJumped = false
    
    local function performDoubleJump()
        local character = LocalPlayer.Character
        local humanoid = character and character:FindFirstChildOfClass('Humanoid')
        
        if humanoid and not hasDoubleJumped then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            wait()
    
            for _,v in next,plr.Backpack:GetChildren() do
                if v.Name == 'C4' and v:FindFirstChild'RemoteEvent' then
                    v.Parent = plr.Character
                    wait()
                    humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
                    wait(0.1)
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    v.RemoteEvent:FireServer(mouse.Hit.LookVector)
                    v.Parent = plr.Backpack
                end
            end
    
            wait(0.2)
    
            for _,v in next,plr.Backpack:GetChildren() do
                if v.Name == 'Grenade' and v:FindFirstChild'RemoteEvent' then
                    v.Parent = plr.Character
                    humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
                    wait(0.1)
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping) 
					wait()                               
                    humanoid:ChangeState(Enum.HumanoidStateType.Freefall)
                    wait(0.1)
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping) 
				    v:Activate()
                    v.Parent = plr.Backpack
                end
            end

        hasDoubleJumped = true
    end
end    

performDoubleJump()
end
end)
end)

window:Section(" Target List")

wait(.1)

window:Dropdown("Kill aura to",{location = Table,flag = "player1",search = true --[[AddsSearchBar]], list = {"Mace","Chainsaw","Knife","Pan","Pencil","Baseball Bat","Scythe","Emerald Greatsword","Blood Dagger"} --[[Wont work when PlayerList = true]], PlayerList = true --[[ Turns the list into the players in the server ]]},function()game.StarterGui:SetCore("SendNotification", {
    Title = "Target:";
    Text = "Choosed sucessfully!";
    Icon = "http://www.roblox.com/asset/?id=5585103223";
    Duration = 5;
    callback = bindableFunction;
})
local usernames        = {(Table["player1"])}-- Reemplaza estos nombres de usuario con los que desees
local Players          = game:GetService("Players")
local LocalPlayer      = Players.LocalPlayer
local Mouse            = LocalPlayer:GetMouse()
local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(Input, IsTyping)
    if IsTyping then return end
    if Input.KeyCode == Enum.KeyCode.KeypadMinus then
        for _, username in pairs(usernames) do
            local TargetPlayer = Players:FindFirstChild(username)
            if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Humanoid") then
                local Target = TargetPlayer.Character:FindFirstChild("Humanoid")
                repeat
                    wait()
                    LocalPlayer.Character:FindFirstChildOfClass("Tool").DamageRemote:FireServer(Target)
                until Target.Health <= 0
            end
        end
    end
end)
end)

wait(.1)

window:Dropdown("Kill aura to",{location = Table,flag = "player2",search = true --[[AddsSearchBar]], list = {"Mace","Chainsaw","Knife","Pan","Pencil","Baseball Bat","Scythe","Emerald Greatsword","Blood Dagger"} --[[Wont work when PlayerList = true]], PlayerList = true --[[ Turns the list into the players in the server ]]},function()game.StarterGui:SetCore("SendNotification", {
    Title = "Target:";
    Text = "Choosed sucessfully!";
    Icon = "http://www.roblox.com/asset/?id=5585103223";
    Duration = 5;
    callback = bindableFunction;
})
local usernames        = {(Table["player2"])}-- Reemplaza estos nombres de usuario con los que desees
local Players          = game:GetService("Players")
local LocalPlayer      = Players.LocalPlayer
local Mouse            = LocalPlayer:GetMouse()
local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(Input, IsTyping)
    if IsTyping then return end
    if Input.KeyCode == Enum.KeyCode.KeypadMinus then
        for _, username in pairs(usernames) do
            local TargetPlayer = Players:FindFirstChild(username)
            if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Humanoid") then
                local Target = TargetPlayer.Character:FindFirstChild("Humanoid")
                repeat
                    wait()
                    LocalPlayer.Character:FindFirstChildOfClass("Tool").DamageRemote:FireServer(Target)
                until Target.Health <= 0
            end
        end
    end
end)
end)

if not _G.IgnoreList then
    _G.IgnoreList = {}
end

local KillingNear = false
local Player = game.Players.LocalPlayer

-- Función para obtener el carácter del jugador
local function GetChar()
    return Player.Character or Player.CharacterAdded:Wait()
end

window:Toggle("Start Kill Aura on them", {location = Table, flag = "enable"}, function(state)
    local isCooldown = false -- Control de enfriamiento
    local allowedUsers = {Table["player1"], Table["player2"]} -- Lista de usuarios permitidos
    local minRange = 500 -- Rango de ataque en studs
    local attackThread -- Hilo de ataque (corrutina)

    -- Función para buscar un jugador permitido más cercano
    local function findNearestTarget()
        local LocalPlayer = game.Players.LocalPlayer
        local playerChar = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local playerRoot = playerChar:FindFirstChild("HumanoidRootPart")

        if not playerRoot then return nil end

        local nearestTarget = nil
        local shortestDistance = minRange

        for _, potentialTarget in pairs(workspace:GetChildren()) do
            if table.find(allowedUsers, potentialTarget.Name) and potentialTarget ~= playerChar then -- Ignorar al jugador local
                local targetHumanoid = potentialTarget:FindFirstChild("Humanoid")
                local targetRoot = potentialTarget:FindFirstChild("HumanoidRootPart")

                if targetHumanoid and targetRoot and targetHumanoid.Health > 0 and not potentialTarget:FindFirstChild("ForceField") then
                    local distance = (targetRoot.Position - playerRoot.Position).Magnitude
                    if distance <= shortestDistance then
                        nearestTarget = targetHumanoid
                        shortestDistance = distance
                    end
                end
            end
        end

        return nearestTarget
    end

    -- Función para buscar cualquier herramienta con DamageRemote que **NO** sea "Kawaii Revolver"
    local function findToolWithDamageRemote()
        local LocalPlayer = game.Players.LocalPlayer
        local tools = {}

        -- Revisar herramientas en el Backpack
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool.Name ~= "Kawaii Revolver" and tool:FindFirstChild("DamageRemote") then
                table.insert(tools, tool)
            end
        end

        -- Revisar herramienta equipada en el personaje
        local equippedTool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if equippedTool and equippedTool.Name ~= "Kawaii Revolver" and equippedTool:FindFirstChild("DamageRemote") then
            table.insert(tools, equippedTool)
        end

        -- Retornar la primera herramienta encontrada
        return tools[1]
    end

    -- Función principal que ejecuta el ataque de manera automática
    local function startAttacking()
        if attackThread then return end -- Evitar múltiples hilos simultáneos

        attackThread = coroutine.create(function()
            while Table.enable do -- Monitorea directamente el estado del flag
                local LocalPlayer = game.Players.LocalPlayer
                local playerChar = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

                -- Buscar el objetivo más cercano permitido
                local target = findNearestTarget()

                -- Buscar una herramienta válida con DamageRemote
                local tool = findToolWithDamageRemote()

                if tool and tool:FindFirstChild("DamageRemote") and target and not isCooldown then
                    local damageRemote = tool.DamageRemote
                    isCooldown = true

                    -- Atacar al objetivo
                    tool.Parent = playerChar -- Equipar la herramienta
                    damageRemote:FireServer(target) -- Ejecutar el evento
                    tool.Parent = LocalPlayer.Backpack -- Guardar la herramienta

                    wait(0.7) -- Tiempo de enfriamiento
                    isCooldown = false
                end

                wait(0.1) -- Breve pausa antes de continuar
            end
        end)

        coroutine.resume(attackThread)
    end

    -- Detener el ataque cuando el toggle está desactivado
    local function stopAttacking()
        if attackThread then
            attackThread = nil -- Eliminar referencia
        end
    end

    -- Controlar el estado del Kill Aura
    if Table.enable then
        startAttacking()
    else
        stopAttacking()
    end
end)

-- Toggle para activar o desactivar la función de Auto Select Dagger
window:Toggle("Tp To Aura User/s", {location = Table, flag = "enable"}, function(state)
    local stopFlag = not state -- Si el toggle está activado, stopFlag será false

    local Input = game:GetService("UserInputService")
    local Plr = game:service'Players'.LocalPlayer
    local Players = game:GetService("Players")
    local Mouse = Plr:GetMouse()

    -- Lista de jugadores a los que se va a hacer teleport
    local targetUsernames = {
        Table["player1"],
        Table["player2"]
    }

    -- Función para mover al jugador local a la posición del objetivo
    function To(position)
        local Chr = Plr.Character
        if Chr ~= nil then
            Chr:MoveTo(position)
        end
    end

    -- Función para teletransportarse a un jugador
    function TeleportToPlayer(targetName)
        local targetPlayer = Players:FindFirstChild(targetName)
        if targetPlayer and targetPlayer.Character then
            local targetRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetRootPart then
                To(targetRootPart.Position)
            end
        else
            warn("Player not found or their character doesn't exist: " .. tostring(targetName))
        end
    end

    -- Función para teletransportarse a todos los jugadores de la lista
    function TeleportToAllPlayers()
        for _, username in ipairs(targetUsernames) do
            if username then
                TeleportToPlayer(username)
            end
        end
    end

    -- Evento cuando se presiona la tecla "Z", solo si el toggle está activado
    if state then
        Input.InputBegan:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.KeypadSix and not stopFlag then
                TeleportToAllPlayers()
            end
        end)
    else
        stopFlag = true -- Desactiva la función cuando se apaga el toggle
    end
end)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local isCooldown = false
local ATTACK_RANGE = 280 -- Rango máximo de ataque en studs
local WAIT_POSITION = Vector3.new(-385, 60, 163) -- Coordenadas de espera

-- Actualiza la referencia al personaje al morir y hacer respawn
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    print("Nuevo personaje generado.")
end)

-- Verifica si el Backpack contiene herramientas válidas (excluyendo "Kawaii Revolver")
local function findToolWithDamageRemote()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    local characterTools = Character and Character:GetChildren() or {}

    if backpack then
        for _, tool in pairs(backpack:GetChildren()) do
            if tool:IsA("Tool") and tool:FindFirstChild("DamageRemote") and tool.Name ~= "Kawaii Revolver" then
                return tool.Name -- Retorna el nombre de la herramienta
            end
        end
    end

    for _, tool in pairs(characterTools) do
        if tool:IsA("Tool") and tool:FindFirstChild("DamageRemote") and tool.Name ~= "Kawaii Revolver" then
            return tool.Name -- Retorna el nombre de la herramienta
        end
    end

    return nil -- No se encontró ninguna herramienta válida con DamageRemote
end

-- Verifica si el Backpack contiene herramientas válidas
local function hasToolsInBackpack(player)
    local backpack = player:FindFirstChild("Backpack")
    if not backpack then return false end

    for _, item in pairs(backpack:GetChildren()) do
        if item:IsA("Tool") then
            return true -- Encontró una herramienta válida
        end
    end
    return false -- No encontró herramientas
end

-- Función para encontrar jugadores válidos dentro del rango y sin ForceField
local function findValidTargets()
    local targets = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")

            -- Validar filtros
            if character and humanoid and rootPart and humanoid.Health > 0 and not character:FindFirstChild("ForceField") then
                local distance = (Character.PrimaryPart.Position - rootPart.Position).Magnitude
                if distance <= ATTACK_RANGE and hasToolsInBackpack(player) then
                    table.insert(targets, player)
                end
            end
        end
    end
    return targets
end

-- Función para atacar a un jugador objetivo
local function attackTarget(targetPlayer)
    local targetCharacter = targetPlayer.Character
    local targetHumanoid = targetCharacter and targetCharacter:FindFirstChild("Humanoid")
    local targetRoot = targetCharacter and targetCharacter.PrimaryPart

    if targetHumanoid and targetRoot then
        local toolName = findToolWithDamageRemote() -- Busca la herramienta con DamageRemote

        if not toolName then
            print("No se encontró ninguna herramienta válida con DamageRemote.")
            return
        end

        local tool = LocalPlayer.Backpack:FindFirstChild(toolName) or Character:FindFirstChild(toolName)
        local damageRemote = tool and tool:FindFirstChild("DamageRemote")
        local targetCFrame = targetCharacter.PrimaryPart.CFrame
        local offset = Vector3.new(0.1, 9, 0)
        local startTime = os.clock() -- Tiempo inicial para limitar el seguimiento
        while Table.trgt and targetHumanoid.Health > 0 and (os.clock() - startTime) < 3 do
            -- Teletransportarse dentro del objetivo usando SetPrimaryPartCFrame
            if Character and Character.PrimaryPart and targetCharacter.PrimaryPart then
 Character:SetPrimaryPartCFrame(targetCharacter.PrimaryPart.CFrame)            end
            wait(0.1) -- Breve pausa para evitar problemas de sincronización

            -- Verificar y usar la herramienta
            if damageRemote and not isCooldown then
                isCooldown = true
                tool.Parent = Character -- Equipar herramienta
                damageRemote:FireServer(targetHumanoid) -- Aplicar daño
                tool.Parent = LocalPlayer.Backpack -- Guardar herramienta
                wait() -- Cooldown entre ataques
                isCooldown = false
            end
        end

        -- Notificación al derrotar al objetivo
        if targetHumanoid.Health <= 0 then
            game.StarterGui:SetCore("SendNotification", {
                Title = "Objective down",
                Text = "The target has been defeated.",
                Duration = 3
            })
        end
    else
        print("El objetivo no tiene Humanoid o PrimaryPart válido.")
    end
end

-- Función principal
local function teleportAndAttack()
    while Table.trgt do -- Se ejecuta mientras el toggle esté activado
        local validTargets = findValidTargets()
        if #validTargets == 0 then
            -- No se encontraron objetivos válidos, teletransportarse a la posición de espera
            if Character and Character.PrimaryPart then
                Character:SetPrimaryPartCFrame(CFrame.new(WAIT_POSITION))
            end
            wait(0.5) -- Esperar antes de intentar nuevamente
        else
            for _, targetPlayer in pairs(validTargets) do
                if not Table.trgt then return end -- Detener inmediatamente si el toggle se apaga
                attackTarget(targetPlayer) -- Atacar al objetivo válido
            end
        end
        wait(0.1) -- Breve pausa antes de buscar más objetivos
    end
    print("El script ha sido detenido.")
end

-- Configuración del Toggle
window:Toggle("Target All", {location = Table, flag = "trgt"}, function(state)
    if state then
        -- Encender el script
        task.spawn(teleportAndAttack) -- Inicia el ciclo principal en un nuevo hilo
    else
        -- Apagar el script (se detendrá automáticamente al verificar Table.trgt)
        print("Script desactivado por toggle.")
    end
end)


local Pressing = false
window:Toggle("Start/Stop Tp",{location = Table, flag = "enable"},function()
local stopFlag = false
game.StarterGui:SetCore("SendNotification", {
    Title = "Current:";
    Text = (Table["player1"]),
    Icon = "http://www.roblox.com/asset/?id=5585095509"; 
    Duration = 5; 
    callback = bindableFunction;
})
local function pressKey()
wait(.3)  
local uis = game:GetService("UserInputService")
uis.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.KeypadSix then  -- Cambia "Y" por la tecla que desees
        pressKey()  -- Aquí llamas a tu función para simular el KeypadSix
    end
end)
end
end)

window:Button("Void (me)",function()
local player = game.Players.LocalPlayer
wait(0.1)
Workspace[player.Name].Torso:Destroy()
wait(1)
local bool = true


if bool then
    game.Workspace.FallenPartsDestroyHeight = 0 / 0
else
    game.Workspace.FallenPartsDestroyHeight = -500
end

game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-989889989898989, -989879898998988, -98999898989899898)
wait(0.3)
Workspace[player.Name].Humanoid:Destroy()
wait(0.2)
Workspace[player.Name].Head:Destroy()
wait(0.2)
Workspace[player.Name]:FindFirstChild("Right Leg"):Destroy()
wait(0.2)
Workspace[player.Name]:FindFirstChild("Left Leg"):Destroy()
wait(0.2)
Workspace[player.Name]:FindFirstChild("Right Arm"):Destroy()
wait(0.2)
Workspace[player.Name]:FindFirstChild("Left Arm"):Destroy()
        StarterGui:SetCore("SendNotification", {
        Title = "Done!",
        Text = "Mix This With Revolver Loop (OP!!).",
        Icon = "http://www.roblox.com/asset/?id=5585095509", -- Agregar ícono
        Duration = 4 -- Duración de la notificación en segundos
})
end)

window:Dropdown("Loop With Revolver",{location = Table,flag = "auth.username",search = true --[[AddsSearchBar]], list = {}, PlayerList = true },function()
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local isCooldown = false
local currentTarget = nil -- Almacena el objetivo actual
wait(1)
-- Función para encontrar un jugador por su username
local function getPlayerByUsername(username)
    for _, player in pairs(Players:GetPlayers()) do
        if player.Name:lower() == username:lower() then
            return player
        end
    end
    return nil
end

-- Función principal que ejecuta el ataque de manera automática
local function startCooking()
    local targetUsername = (Table["auth.username"]) -- Obtener el username del Dropdown
    local targetPlayer = getPlayerByUsername(targetUsername)

    -- Si el objetivo ha cambiado, actualizamos `currentTarget`
    if targetPlayer ~= currentTarget then
        currentTarget = targetPlayer
    end

    if currentTarget and currentTarget.Character and currentTarget.Character:FindFirstChild("Humanoid") then
        local Target = currentTarget.Character.Humanoid
        local tool = LocalPlayer.Backpack:FindFirstChild("Kawaii Revolver") -- Buscar el tool en el Backpack
        local damageRemote = tool and tool:FindFirstChild("DamageRemote") -- Verificar la existencia del DamageRemote

        if damageRemote then
            repeat
                -- Si hay un cambio de objetivo, rompemos el ciclo
                if currentTarget ~= targetPlayer then break end
                
                if Target and Target.Health > 0 and not isCooldown then
                    isCooldown = true

                    tool.Parent = Character -- Equipar la herramienta
                    damageRemote:FireServer(Target) -- Ejecutar el evento
                    tool.Parent = LocalPlayer.Backpack -- Volver a guardar la herramienta

                    wait(0.7)
                    isCooldown = false
                end
                wait(0.1)
            until not Target or Target.Health <= 0

            -- Notificación al jugador cuando el objetivo muere
            if Target.Health <= 0 then
                StarterGui:SetCore("SendNotification", {
                    Title = "Objective down",
                    Text = "The target has been defeated.",
                    Duration = 3
                })
            end
        else
            print("DamageRemote no encontrado en la herramienta.")
        end
    else
        StarterGui:SetCore("SendNotification", {
            Title = "Player not found",
            Text = "The player is nil or has left.",
            Icon = "http://www.roblox.com/asset/?id=5585095509",
            Duration = 3
        })
    end
end

-- Evento para detectar la tecla K9
UserInputService.InputBegan:Connect(function(input, isProcessed)
    if isProcessed then return end
    if input.KeyCode == Enum.KeyCode.KeypadNine then
        startCooking() -- Ejecutar la función al presionar 9
        StarterGui:SetCore("SendNotification", {
            Title = "Started!",
            Text = "Wait...",
            Icon = "http://www.roblox.com/asset/?id=5585095509",
            Duration = 3
        })
    end
end)

-- Evento que se ejecuta cada vez que el personaje reaparece
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter -- Actualizar la referencia al nuevo personaje
    wait(1) -- Esperar a que el personaje cargue completamente
end)
end)

local activeCoroutine -- Variable para almacenar la coroutine en ejecución

window:Toggle("Start/Stop", {location = Table, flag = "revz"}, function(state)
    -- Se activa el toggle
    if state then
        game.StarterGui:SetCore("SendNotification", {
            Title = "WARN";
            Text = "Once enabled this dont disable and enabled it causes kick",
            Icon = "http://www.roblox.com/asset/?id=5585095509";
            Duration = 5;
            callback = bindableFunction;
        })

        -- Iniciar la coroutine sólo si no está activa
        if not activeCoroutine then
            activeCoroutine = coroutine.create(function()
                while Table.revz do wait(0.2)
                    game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.KeypadNine, false, game)
                    wait(3) -- Espera de 0.5 segundos entre cada pulsación.
                end
                activeCoroutine = nil -- Al salir del bucle, liberamos la coroutine
            end)
            coroutine.resume(activeCoroutine)
        end
    else
        -- Si el toggle se apaga, el bucle se detendrá automáticamente cuando `Table.enable` sea `false`
        Table.revz = false
    end
end)


window:Dropdown("Auto Void a Player",{location = Table,flag = "auth%.username",search = true --[[AddsSearchBar]], list = {"Mace","Chainsaw","Knife","Pan","Pencil","Baseball Bat","Scythe", "Emerald Greatsword","Blood Dagger","Frost Spear"}--[[Wont work when PlayerList = true]], PlayerList = true --[[ Turns the list into the players in the server ]]},function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local isCooldown = false

local function getPlayerByUsername(username)
    for _, player in pairs(Players:GetPlayers()) do
        if player.Name:lower() == username:lower() then
            return player
        end
    end
    return nil
end

local function isBeingCarried(targetPlayer)
    local targetChar = game.Workspace:FindFirstChild(targetPlayer.Name)
    if targetChar then
        local beingCarried = targetChar:FindFirstChild("Being Carried")
        return beingCarried and beingCarried.Value == true
    end
    return false
end

local speaker = game.Players.LocalPlayer

-- Función para girar el RootPart del personaje
local function GirarRootPart()
    local humanoid = speaker.Character:FindFirstChildWhichIsA("Humanoid")

    if humanoid then
        -- Hace que el personaje se siente
        humanoid.Sit = true
        
        -- Espera un breve momento
        task.wait(0.1)
        
        -- Ejecuta el giro 6 veces
        for i = 1, 3 do
            humanoid.RootPart.CFrame = humanoid.RootPart.CFrame * CFrame.Angles(math.pi * 0.8, 0.4, 0.8)
            
            -- Espera un breve momento entre cada giro
            task.wait(0.1)
        end
        
        -- Detiene todas las animaciones actualmente en reproducción
        for _, animationTrack in ipairs(humanoid:GetPlayingAnimationTracks()) do
            animationTrack:Stop()
        end
    end
end

local function sFLY()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer

    local FLYING = false
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0

    local function FLY()
        FLYING = true
        local T = player.Character:FindFirstChild("HumanoidRootPart")
        local BG = Instance.new('BodyGyro', T)
        local BV = Instance.new('BodyVelocity', T)

        BG.P = 9e4
        BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.cframe = T.CFrame

        BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
        BV.velocity = Vector3.zero

        game:GetService("RunService").RenderStepped:Connect(function()
            if FLYING then
                BV.velocity = ((workspace.CurrentCamera.CFrame.LookVector * (CONTROL.F + CONTROL.B)) +
                    ((workspace.CurrentCamera.CFrame.RightVector * (CONTROL.L + CONTROL.R)))) * SPEED
                BG.cframe = workspace.CurrentCamera.CFrame
            else
                BV:Destroy()
                BG:Destroy()
            end
        end)
    end

    local function setupControls()
        local UserInputService = game:GetService("UserInputService")
        UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            local key = input.KeyCode

            if key == Enum.KeyCode.W then CONTROL.F = 1 SPEED = 50 end
            if key == Enum.KeyCode.S then CONTROL.B = -1 SPEED = 50 end
            if key == Enum.KeyCode.A then CONTROL.L = -1 SPEED = 50 end
            if key == Enum.KeyCode.D then CONTROL.R = 1 SPEED = 50 end
            if key == Enum.KeyCode.E then CONTROL.Q = 2 SPEED = 50 end
            if key == Enum.KeyCode.Q then CONTROL.E = -2 SPEED = 50 end
        end)

        UserInputService.InputEnded:Connect(function(input)
            local key = input.KeyCode

            if key == Enum.KeyCode.W then CONTROL.F = 0 end
            if key == Enum.KeyCode.S then CONTROL.B = 0 end
            if key == Enum.KeyCode.A then CONTROL.L = 0 end
            if key == Enum.KeyCode.D then CONTROL.R = 0 end
            if key == Enum.KeyCode.E then CONTROL.Q = 0 end
            if key == Enum.KeyCode.Q then CONTROL.E = 0 end
        end)
    end

    setupControls()
    FLY()
end

local function teleportNearPlayerAndTryPickup(targetPlayer)
    local root = Character:FindFirstChild("Right Arm")
    local targetRoot = targetPlayer.Character and targetPlayer.Character:FindFirstChild("Torso")

    if root and targetRoot then
        while not isBeingCarried(targetPlayer) do
            if not targetPlayer.Character or not targetPlayer.Character:FindFirstChildOfClass("Humanoid") or targetPlayer.Character.Humanoid.Health <= 0 then
                -- Detener si el objetivo está muerto
                break
            end
            wait(0.1)
            GirarRootPart()
            wait(0.1)
            sFLY()
            root.CFrame = targetRoot.CFrame * CFrame.new(0.4, 0.1, 0.5)
            local pickupRemote = Character:FindFirstChild("PickupRemote")
            if pickupRemote then
			wait(0.2)
                pickupRemote:FireServer()
            end
            wait(0.1)
        end
     -- **Ejecución adicional tras el PickupRemote**
        wait(0.1)
        local bool = true

        if bool then
            game.Workspace.FallenPartsDestroyHeight = 0 / 0 -- Forzar error para prevenir interacción.
        else
            game.Workspace.FallenPartsDestroyHeight = -800
        end

        if Character:FindFirstChild("HumanoidRootPart") then
            Character.HumanoidRootPart.CFrame = CFrame.new(-9898899898989, -9898798998988, -989998989899898)
        end

        local humanoid = Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            wait()
            humanoid.Health = 0
        end

        game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Two, false, game)
    end
end

local function orbitPlayer(targetUsername, speed, distance, height)
    local targetPlayer = getPlayerByUsername(targetUsername)
    if not targetPlayer or not targetPlayer.Character then return end

    local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    local root = Character:FindFirstChild("HumanoidRootPart")
    local rotation = 0.3

    if root and targetHumanoid then
        local orbitConnection
        orbitConnection = RunService.Heartbeat:Connect(function()
            if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("Humanoid") or targetHumanoid.Health <= 0 then
                -- Detener si el objetivo está muerto
                if orbitConnection then
                    orbitConnection:Disconnect()
                    orbitConnection = nil
                end
                StarterGui:SetCore("SendNotification", {Title = "Target is dead", Duration = 3})
                return
            end

            rotation = rotation + speed
            root.CFrame = CFrame.new(targetHumanoid.RootPart.Position) * CFrame.Angles(0, math.rad(rotation), 0.5) * CFrame.new(distance, height, 0)
        end)

local tool = LocalPlayer.Backpack:FindFirstChild("Katana")
if tool and tool:FindFirstChild("DamageRemote") then
    local damageRemote = tool.DamageRemote
    local cooldownDuration = 0
    local heartbeatConnection
    heartbeatConnection = RunService.Heartbeat:Connect(function()
        if targetHumanoid.Health <= 17 then
            print("La salud es 17 o menos, deteniendo el evento.")
            heartbeatConnection:Disconnect()
        end
                if targetHumanoid and targetHumanoid.Health <= 17 then
                    if orbitConnection then
                        orbitConnection:Disconnect()
                        orbitConnection = nil
                    end
                    teleportNearPlayerAndTryPickup(targetPlayer)
                elseif not isCooldown then
                    isCooldown = true
                    tool.Parent = Character
                    damageRemote:FireServer(targetHumanoid)
                    tool.Parent = LocalPlayer.Backpack
                    wait(cooldownDuration)
                    isCooldown = false
                end
            end)
        end
    end
end

-- Start the orbit with the target player
orbitPlayer(Table["auth%.username"], 18, -11, -9) -- esto dejalo asi
end)


window:Dropdown("Camp a player to void",{location = Table,flag = "username%!",search = true --[[AddsSearchBar]], list = {"Mace","Chainsaw","Knife","Pan","Pencil","Baseball Bat","Scythe", "Emerald Greatsword","Blood Dagger","Frost Spear"}--[[Wont work when PlayerList = true]], PlayerList = true --[[ Turns the list into the players in the server ]]},function()
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- Funcion para verificar si el objetivo esta en estado de ragdoll o tiene baja salud
local function checkRagdollOrLowHealth(targetChar)
    local humanoid = targetChar:FindFirstChild("Humanoid")
    if humanoid and (humanoid.Health <= 17 and humanoid.Health > 0) then
        return true
    end

    -- Verificar si el BoolValue "Ragdolled" esta en true osea que si esta siendo cargado/carried
    local ragdolled = targetChar:FindFirstChild("Ragdolled")
    if ragdolled and ragdolled.Value == true then
        return true
    end
    return false
end

local function sFLY()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer

    local FLYING = false
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0

    local function FLY()
        FLYING = true
        local T = player.Character:FindFirstChild("HumanoidRootPart")
        local BG = Instance.new('BodyGyro', T)
        local BV = Instance.new('BodyVelocity', T)

        BG.P = 9e4
        BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.cframe = T.CFrame

        BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
        BV.velocity = Vector3.zero

        game:GetService("RunService").RenderStepped:Connect(function()
            if FLYING then
                BV.velocity = ((workspace.CurrentCamera.CFrame.LookVector * (CONTROL.F + CONTROL.B)) +
                    ((workspace.CurrentCamera.CFrame.RightVector * (CONTROL.L + CONTROL.R)))) * SPEED
                BG.cframe = workspace.CurrentCamera.CFrame
            else
                BV:Destroy()
                BG:Destroy()
            end
        end)
    end

    local function setupControls()
        local UserInputService = game:GetService("UserInputService")
        UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            local key = input.KeyCode

            if key == Enum.KeyCode.W then CONTROL.F = 1 SPEED = 50 end
            if key == Enum.KeyCode.S then CONTROL.B = -1 SPEED = 50 end
            if key == Enum.KeyCode.A then CONTROL.L = -1 SPEED = 50 end
            if key == Enum.KeyCode.D then CONTROL.R = 1 SPEED = 50 end
            if key == Enum.KeyCode.E then CONTROL.Q = 2 SPEED = 50 end
            if key == Enum.KeyCode.Q then CONTROL.E = -2 SPEED = 50 end
        end)

        UserInputService.InputEnded:Connect(function(input)
            local key = input.KeyCode

            if key == Enum.KeyCode.W then CONTROL.F = 0 end
            if key == Enum.KeyCode.S then CONTROL.B = 0 end
            if key == Enum.KeyCode.A then CONTROL.L = 0 end
            if key == Enum.KeyCode.D then CONTROL.R = 0 end
            if key == Enum.KeyCode.E then CONTROL.Q = 0 end
            if key == Enum.KeyCode.Q then CONTROL.E = 0 end
        end)
    end

    setupControls()
    FLY()
end

local speaker = game.Players.LocalPlayer

-- Función para girar el RootPart del personaje
local function GirarRootPart()
    local humanoid = speaker.Character:FindFirstChildWhichIsA("Humanoid")

    if humanoid then
        -- Hace que el personaje se siente
        humanoid.Sit = true
        
        -- Espera un breve momento
        task.wait(0.1)
        
        -- Ejecuta el giro 6 veces
        for i = 1, 3 do
            humanoid.RootPart.CFrame = humanoid.RootPart.CFrame * CFrame.Angles(math.pi * 0.8, 0.4, 0.8)
            
            -- Espera un breve momento entre cada giro
            task.wait(0.1)
        end
        
        -- Detiene todas las animaciones actualmente en reproducción
        for _, animationTrack in ipairs(humanoid:GetPlayingAnimationTracks()) do
            animationTrack:Stop()
        end
    end
end

-- Funcion para ejecutar todas las acciones si el jugador esta en estado Ragdolled o con baja salud
local function executeIfRagdolledOrLowHealth(targetPlayer)
    local targetChar = Workspace:FindFirstChild(targetPlayer.Name)
    if targetChar then
        local humanoid = targetChar:FindFirstChild("Humanoid")

        -- Verificar si el objetivo esta vivo antes de proceder
        if humanoid and humanoid.Health > 0 then
            local speaker = Players.LocalPlayer
            local root = speaker.Character and speaker.Character:FindFirstChild("HumanoidRootPart")
            local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")

            if root and targetRoot then
                -- Repetir hasta que el BoolValue "Being Carried" este en true o el objetivo muera
                while true do
                    local beingCarried = targetChar:FindFirstChild("Being Carried")
                    humanoid = targetChar:FindFirstChild("Humanoid") -- Volver a obtener la referencia por si cambia
                    if humanoid and humanoid.Health <= 0 then
                        -- Detener el bucle si el objetivo ha muerto
                        warn("El objetivo ha muerto. Deteniendo el teletransporte.")
                        break
                    end
                    
                    if beingCarried and beingCarried.Value == true then
                        break
                    end

                    -- Teletransportarse cerca del objetivo
                    root.CFrame = targetRoot.CFrame * CFrame.new(0.2, 0.1, 0.2)
                    GirarRootPart()
                    wait(0.1)
                    sFLY()
                    wait(0.1)
                    -- Variable para almacenar al jugador local                    -- Llamar al RemoteEvent "PickupRemote" que es el carry
                    local pickupRemote = speaker.Character:FindFirstChild("PickupRemote")
                    if pickupRemote then
                        pickupRemote:FireServer()
                    else
                        warn("No se encontró PickupRemote en el personaje.")
                        break
                    end
                    wait(0.1)
                end

                -- Ejecutar el void
       game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Two, false, game)
        wait(0.1)
        local character = game.Players.LocalPlayer.Character
      local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            if rootPart then
            wait(0.1) 
            local bool = true
if bool then
    game.Workspace.FallenPartsDestroyHeight = 0 / 0
else
    game.Workspace.FallenPartsDestroyHeight = -700
end

game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-989889998989, -989879898988, -98999898989898)
wait(0.1)
local player = game.Players.LocalPlayer  -- Obtener el jugador local
local humanoid = game.Workspace[player.Name].Humanoid  -- Obtener el Humanoid del jugador local
humanoid.Health = 0
       end
            else
                warn("No se encontro el HumanoidRootPart para el teletransporte.")
            end
        else
            warn("El objetivo no esta vivo no se puede teletransportar.")
        end
    else
        warn("El objetivo esta fuera del servidor posiblemente.")
    end
end

-- funcion principal para campear y esperar a que el objetivo entre en ragdoll o tenga baja salud
local function campUntilRagdollOrLowHealth(targetPlayerName)
    while true do
        local targetPlayer = Players:FindFirstChild(targetPlayerName)
        if targetPlayer then
            local targetChar = Workspace:FindFirstChild(targetPlayer.Name)

            -- Si el personaje está en el mapa, verificar su estado
            if targetChar and checkRagdollOrLowHealth(targetChar) then
                executeIfRagdolledOrLowHealth(targetPlayer)
            end
        else
            -- El target no esta disponible aun, seguir esperando
            warn("Esperando a que el jugador objetivo este en el juego o respawnee...")
        end

        wait(1) -- Esperar 1 segundo antes de verificar de nuevo
    end
end

-- Ejemplo de uso
local targetPlayerName = (Table["username%!"]) -- Cambia "Target user aqui" por el usuario del objetivo
campUntilRagdollOrLowHealth(targetPlayerName)
end)

window:Dropdown("Monitor a player",{location = Table,flag = "username%$",search = true --[[AddsSearchBar]], list = {"Mace","Chainsaw","Knife","Pan","Pencil","Baseball Bat","Scythe", "Emerald Greatsword","Blood Dagger","Frost Spear"}--[[Wont work when PlayerList = true]], PlayerList = true --[[ Turns the list into the players in the server ]]},function()
-- Configura el nombre del jugador que deseas monitorear
local jugadorMonitoreado = (Table["username%$"]) -- Cambia esto al nombre del jugador que quieres monitorear

-- Obtener servicios de Roblox necesarios
local Players = game:GetService("Players")

-- Crear una GUI para notificaciones
local notificationGui = Instance.new("ScreenGui")
notificationGui.Name = "NotificationGui"
notificationGui.ResetOnSpawn = false -- Evitar que se reinicie al respawnear
notificationGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

-- Crear etiqueta de notificación
local notificationLabel = Instance.new("TextLabel")
notificationLabel.Size = UDim2.new(0.3, 0, 0.05, 0) -- Tamaño del cuadro de notificación
notificationLabel.Position = UDim2.new(1, -10, 0, 10) -- Posición en la esquina superior derecha
notificationLabel.AnchorPoint = Vector2.new(1, 0) -- Anclar a la esquina superior derecha
notificationLabel.TextColor3 = Color3.new(1, 1, 1)
notificationLabel.BackgroundColor3 = Color3.new(0, 0, 0)
notificationLabel.TextScaled = true
notificationLabel.Visible = false
notificationLabel.Parent = notificationGui

-- Crear botones para "Sí" y "No"
local yesButton = Instance.new("TextButton")
yesButton.Size = UDim2.new(0.1, 0, 0.05, 0)
yesButton.Position = UDim2.new(0.7, 0, 0.1, 50) -- Abajo del cuadro principal
yesButton.Text = "Sí"
yesButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
yesButton.Visible = false
yesButton.Parent = notificationGui

local noButton = Instance.new("TextButton")
noButton.Size = UDim2.new(0.1, 0, 0.05, 0)
noButton.Position = UDim2.new(0.85, 0, 0.1, 50) -- Abajo del cuadro principal
noButton.Text = "No"
noButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
noButton.Visible = false
noButton.Parent = notificationGui

-- Crear etiqueta para mostrar la cuenta regresiva
local countdownLabel = Instance.new("TextLabel")
countdownLabel.Size = UDim2.new(0.2, 0, 0.03, 0)
countdownLabel.Position = UDim2.new(1, -10, 0, 70) -- Debajo del mensaje principal
countdownLabel.AnchorPoint = Vector2.new(1, 0)
countdownLabel.TextColor3 = Color3.new(1, 1, 1)
countdownLabel.BackgroundTransparency = 1
countdownLabel.TextScaled = true
countdownLabel.Visible = false
countdownLabel.Parent = notificationGui

-- Variables para las conexiones del botón "Sí" y "No"
local yesConnection
local noConnection

-- Función para mostrar notificaciones con cuenta regresiva
local function showNotification(message, color, showButtons, targetPlayer)
    notificationLabel.Text = message
    notificationLabel.BackgroundColor3 = color
    notificationLabel.Visible = true
    yesButton.Visible = showButtons
    noButton.Visible = showButtons

    if showButtons then
        countdownLabel.Visible = true
        local countdownTime = 8 -- Tiempo en segundos para ocultar los botones

        -- Limpiar conexiones previas
        if yesConnection then
            yesConnection:Disconnect()
        end
        if noConnection then
            noConnection:Disconnect()
        end

        -- Conectar el botón "Sí" al teletransporte
        yesConnection = yesButton.MouseButton1Click:Connect(function()
            if targetPlayer and targetPlayer.Character and targetPlayer.Character.PrimaryPart then
                local localPlayer = game.Players.LocalPlayer
                                    -- Ejecutar el segundo script
                    local targetHRP = targetPlayer.Character.HumanoidRootPart
                    local player = game.Players.LocalPlayer

                    -- Calcular la posición 5 studs frente al jugador objetivo
                    local direction = targetHRP.CFrame.LookVector

				local targetPosition = targetHRP.Position - (direction * 5)             
			
		     if localPlayer.Character and localPlayer.Character.PrimaryPart then
                    player.Character:MoveTo(targetPosition)
                    showNotification("¡Teletransportado al objetivo!", Color3.fromRGB(0, 255, 255), false)
                    

                    -- Equipar la herramienta si existe en la mochila
                    for _, v in pairs(player.Backpack:GetChildren()) do
                        if v.Name == "Spiked Trap" then
                            player.Character.Humanoid:EquipTool(v)

                            -- Mover el personaje local a la posición calculada
                            player.Character:MoveTo(targetPosition)

                            -- Esperar a que el personaje esté en la posición correcta
                            wait(0.5)
                            repeat
                                game:GetService("RunService").Heartbeat:Wait()
                            until (player.Character.HumanoidRootPart.Position - targetPosition).Magnitude < 2

                            -- Alinear al personaje hacia el objetivo
                            local lookAtTarget = CFrame.new(player.Character.HumanoidRootPart.Position, targetHRP.Position)
                            player.Character.HumanoidRootPart.CFrame = lookAtTarget

                            -- Esperar un momento para garantizar que la alineación esté completa
                            wait(0.5)

                            -- Intentar colocar la trampa debajo del objetivo
                            while v.Parent == player.Character do
                                -- Activar la herramienta (puede intentar varias veces hasta que se coloque correctamente)
                                v:Activate()
                                game:GetService("RunService").Heartbeat:Wait()
                            end

                            print("Trampa colocada con éxito.")
                            break
                        end
                    end
                else
                    showNotification("No se pudo realizar el teletransporte: Verifica que tu personaje esté presente.", Color3.fromRGB(255, 0, 0), false)
                end
            else
                showNotification("El objetivo esta en el void actualmente.", Color3.fromRGB(255, 0, 0), false)
            end
        end)

        -- Conectar el botón "No" para ocultar
        noConnection = noButton.MouseButton1Click:Connect(function()
            showNotification("No se realizó el teletransporte.", Color3.fromRGB(255, 165, 0), false)
        end)

        -- Mostrar cuenta regresiva
        for i = countdownTime, 1, -1 do
            countdownLabel.Text = "Desapareciendo en: " .. i .. "s"
            task.wait(1)
        end

        -- Ocultar todo después de la cuenta regresiva
        notificationLabel.Visible = false
        yesButton.Visible = false
        noButton.Visible = false
        countdownLabel.Visible = false
    else
        countdownLabel.Visible = false
    end
end

-- Función para manejar la entrada del jugador monitoreado
local function onPlayerAdded(player)
    if player.Name == jugadorMonitoreado then
        showNotification("El objetivo ha entrado, ¿deseas hacer TP?", Color3.fromRGB(0, 255, 0), true, player)
    end
end

-- Función para manejar la salida del jugador monitoreado
local function onPlayerRemoving(player)
    if player.Name == jugadorMonitoreado then
        showNotification(player.Name .. " ha salido del juego.", Color3.fromRGB(255, 0, 0), false)
    end
end

-- Monitorear todos los jugadores actuales y futuros
local function startMonitoring()
    -- Conectar eventos para jugadores existentes
    for _, player in ipairs(Players:GetPlayers()) do
        onPlayerAdded(player)
    end

    -- Conectar eventos de entrada y salida
    Players.PlayerAdded:Connect(onPlayerAdded)
    Players.PlayerRemoving:Connect(onPlayerRemoving)
end

-- Iniciar monitoreo constante
startMonitoring()
end)

window:Section(" Misc. Functions")

local Farming = false
local requiredPosition = Vector3.new(-519, 86, 82) -- Coordenada requerida para ejecutar las funciones
local requiredTolerance = 5 -- Tolerancia en studs para considerar que el personaje está en la posición

window:Toggle("Farm Grenade 2", {location = Table, flag = "Farming"}, function()
    game.StarterGui:SetCore("SendNotification", {
        Title = "Dupe:",
        Text = "Hold on..",
        Icon = "http://www.roblox.com/asset/?id=5585095509",
        Duration = 3
    })

    if Farming then
        Farming = false
    else
        Farming = true
        spawn(function()
            while Farming do
                local player = game.Players.LocalPlayer

                -- Asegurarse de que el personaje esté spawneado
                repeat
                    wait()
                until player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0

                -- Verificar si el personaje está en la posición requerida
                local characterPosition = player.Character.HumanoidRootPart.Position
                local distance = (characterPosition - requiredPosition).Magnitude

                if distance > requiredTolerance then
                    -- Teletransportar al jugador a la posición requerida
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(requiredPosition + Vector3.new(0, 2, 0))
                end

                -- Desactivar el menú
                local playerGui = player:FindFirstChild("PlayerGui")
                if playerGui then
                    local menuScreen = playerGui:FindFirstChild("Menu Screen")
                    if menuScreen and menuScreen:IsA("ScreenGui") then
                        menuScreen.Enabled = false
                        local remoteEvent = menuScreen:FindFirstChild("RemoteEvent")
                        if remoteEvent then
                            remoteEvent:FireServer("Holloween Dagger")
                        else
                            warn("RemoteEvent not found in Menu Screen.")
                        end
                    else
                        warn("Menu Screen not found or is not a ScreenGui.")
                    end
                else
                    warn("PlayerGui not found.")
                end

                -- Crear parte y teletransportar al bloque
                local partName = "UniqueBlock"
                if not game.Workspace:FindFirstChild(partName) then
                    local part = Instance.new("Part")
                    part.Name = partName
                    part.Size = Vector3.new(4.3, 1.7, 2.6)
                    part.Position = requiredPosition
                    part.Anchored = true
                    part.Parent = game.Workspace
                end

                -- Equipar Granada Roja
                local backpack = player.Backpack
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                for _, tool in ipairs(backpack:GetChildren()) do
                    if tool:IsA("Tool") and tool.Name == "Grenade 2" then
                        humanoid:EquipTool(tool)
                        wait(0.2)
                    end
                end

                wait(0.1) -- Esperar antes de hacer spawn

                -- Teletransportar la herramienta
                local function TeleportTool()
                    local character = player.Character
                    if character then
                        local tool = character:FindFirstChild("Grenade 2")
                        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                        if tool and humanoidRootPart then
                            local backPosition = humanoidRootPart.Position - (humanoidRootPart.CFrame.LookVector * -5)
                            local finalPosition = backPosition + (humanoidRootPart.CFrame.LookVector * -4) - Vector3.new(0, 10, 0)
                            tool:MoveTo(finalPosition)
                        end
                    end
                end

                TeleportTool()

                wait(0.2) -- Esperar antes de soltar la herramienta

                -- Soltar la herramienta (simulando Backspace)
                game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Backspace, false, game)

                wait(0.2) -- Esperar antes de resetear

                -- Resetear al jugador
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    player.Character.Humanoid.Health = 0
                end

                -- Esperar a que el personaje vuelva a spawnear
                repeat
                    wait(0.2)
                until player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0

                wait(0.3)
            end
        end)
    end
end)


local Farming = false
local stopFlag = false  -- Control para el bucle
local requiredPosition = Vector3.new(-519, 86, 82)  -- Coordenada requerida para ejecutar las funciones

window:Toggle("Farm Holl Dagger",{location = Table, flag = "Farming"},function()
    game.StarterGui:SetCore("SendNotification", {
        Title = "Dupe:",
        Text = "Hold on..",
        Icon = "http://www.roblox.com/asset/?id=5585095509";
        Duration = 3,
        callback = bindableFunction,
    })

    if Farming then
        Farming = false
    else
        Farming = true
        spawn(function()
            repeat
                local player = game.Players.LocalPlayer

                -- Esperar hasta que el personaje haya spawneado
                repeat
                    wait(0.1)
                until player.Character and player.Character:FindFirstChild("HumanoidRootPart")

                -- Verificar si el personaje está en la posición requerida
                local characterPosition = player.Character.HumanoidRootPart.Position
                local distance = (characterPosition - requiredPosition).Magnitude

                if distance > 5 then  -- Si el personaje está a más de 5 studs de la coordenada
                    -- Teletransportar al jugador a la coordenada requerida
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(requiredPosition + Vector3.new(0, 2, 0))  -- 2 studs por encima del bloque
                end

                -- Desactivar el menú
                local playerGui = player:FindFirstChild("PlayerGui")
                if playerGui then
                    local menuScreen = playerGui:FindFirstChild("Menu Screen")
                    if menuScreen and menuScreen:IsA("ScreenGui") then
                        menuScreen.Enabled = false
                        if menuScreen:FindFirstChild("RemoteEvent") then
                            menuScreen.RemoteEvent:FireServer("Holloween Dagger")
                        else
                            warn("RemoteEvent not found in Menu Screen.")
                        end
                    else
                        warn("Menu Screen not found or is not a ScreenGui.")
                    end
                else
                    warn("PlayerGui not found.")
                end

                -- Crear parte y teletransportar al bloque
                local partPosition = Vector3.new(-519, 86, 82)
                local partSize = Vector3.new(4.3, 1.7, 2.6)
                local partName = "UniqueBlock"
                local existingPart = game.Workspace:FindFirstChild(partName)

                if not existingPart then
                    local part = Instance.new("Part")
                    part.Name = partName
                    part.Size = partSize
                    part.Position = partPosition
                    part.Anchored = true
                    part.Parent = game.Workspace
                end

                -- Equipar Granada Roja
                local backpack = player.Backpack
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                for _, tool in ipairs(backpack:GetChildren()) do
                    if tool:IsA("Tool") and tool.Name == "Holloween Dagger" then
                        humanoid:EquipTool(tool)
                        wait(0.2)
                    end
                end

                wait(0.1)

                -- Soltar la herramienta (simulando Backspace)
                game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Backspace, false, game)

                wait(0.1)

                -- Resetear al jugador
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    player.Character.Humanoid.Health = 0
                    wait(0.1)
                end

                -- Detener el bucle si el toggle está apagado
                if not Farming then
                    break
                end

                wait(0.5)
            until stopFlag or not Farming
        end)
    end
end)

window:Button("Teleport To Farm Zone",function()
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-519, 86, 82)
end)

window:Button("Teleport Up (Exit)",function()
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-511, 100, 67)
end)

window:Button("Invisible Choose Weapon",function()
local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()

game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Menu Screen").Enabled = false
Player.PlayerGui["Menu Screen"]:Destroy()
end)

window:Button("Collect All (Fixed!)",function()
local root = game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("HumanoidRootPart") or game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("BasePart")
wait(0.1)
local function touch(x)
    x = x:FindFirstAncestorWhichIsA("BasePart")
    if x and firetouchinterest then
        if x.Name == "Button" then
            -- Ignorar el 'Button de la spiked trap'
            return
        end
        
        task.spawn(function()
            firetouchinterest(x, root, 1)
            wait()
            firetouchinterest(x, root, 0)
        end)
        x.CFrame = root.CFrame
    end
end

for _, descendant in ipairs(workspace:GetDescendants()) do
    if descendant:IsA("TouchTransmitter") then
        touch(descendant)
    end
end
end) 


window:Dropdown("Teleport to",{location = Table,flag = "tp",search = true --[[AddsSearchBar]], list = {"Mace","Chainsaw","Knife","Pan","Pencil","Baseball Bat","Scythe", "Emerald Greatsword","Blood Dagger","Frost Spear"}--[[Wont work when PlayerList = true]], PlayerList = true --[[ Turns the list into the players in the server ]]},function()
game.StarterGui:SetCore("SendNotification", {
    Title = "Yo";
    Text = "Press Z to tp";
    Icon = "http://www.roblox.com/asset/?id=5585095509";
    Duration = 3;
    callback = bindableFunction;
})
local Imput = game:GetService("UserInputService")
local Plr = game:service'Players'.LocalPlayer
local Players = game:GetService("Players")
local Mouse = Plr:GetMouse()

-- Coloca aquí el username del jugador al que quieres hacer teleport
local targetUsername = (Table["tp"])

function To(position)
    local Chr = Plr.Character
    if Chr ~= nil then
        Chr:MoveTo(position)
    end
end

function TeleportToPlayer(targetName)
    local targetPlayer = Players:FindFirstChild(targetName)
    if targetPlayer and targetPlayer.Character then
        local targetRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if targetRootPart then
            To(targetRootPart.Position)
        end
    else
        warn("Player not found or their character doesn't exist.")
    end
end

Imput.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Z then
        TeleportToPlayer(targetUsername)
    end
end)
end)

window:Button("Spam Grenade 2",function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Variables de configuración
local barrierDuration = 8 -- Duración en segundos
local radius = 20 -- Aumentamos el radio de la barrera a 20 studs
local segments = 100 -- Cantidad de columnas para cerrar el círculo
local heightSegments = 10 -- Número de divisiones verticales
local barrierHeight = 15 -- Altura total de la barrera
local barrierColor = Color3.new(1, 0, 0) -- Color de la barrera (rojo)

-- Función para crear la barrera
local function createBarrier()
    local barrierFolder = Instance.new("Folder") -- Contenedor para los segmentos
    barrierFolder.Name = "Barrier"
    barrierFolder.Parent = workspace

    -- Obtener la posición inicial del personaje
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        warn("No se encontró el HumanoidRootPart del personaje.")
        return
    end

    -- Obtener la posición en el suelo del personaje (usando su HumanoidRootPart)
    local basePosition = humanoidRootPart.Position - Vector3.new(0, humanoidRootPart.Size.Y / 2, 0) -- Base al nivel del suelo
    local segmentHeight = barrierHeight / heightSegments -- Altura de cada sección vertical

    -- Crear los segmentos de la barrera
    for i = 1, segments do
        local angle = math.rad((360 / segments) * i) -- Convertir ángulo a radianes
        local x = math.cos(angle) * radius
        local z = math.sin(angle) * radius

        -- Crear columnas verticales
        for j = 0, heightSegments - 1 do
            local part = Instance.new("Part")
            part.Size = Vector3.new(1, segmentHeight, 1) -- Mantén el tamaño de cada parte
            part.Anchored = true
            part.CanCollide = true
            part.Color = barrierColor
            part.Transparency = 0.5 -- Ajustar la transparencia (0.5 es semi-transparente)

            -- Ajuste para que la barrera comience desde el suelo
            local verticalOffset = j * segmentHeight + (segmentHeight / 2)
            part.CFrame = CFrame.new(basePosition.X + x, basePosition.Y + verticalOffset, basePosition.Z + z)
            part.Parent = barrierFolder
        end
    end

    -- Destruir la barrera después de la duración especificada
    task.delay(barrierDuration, function()
        barrierFolder:Destroy()
    end)
end

-- Llamar a la función para crear la barrera
createBarrier()

local radius = 5 -- Radio de distancia alrededor del personaje
for _, v in next, plr.Backpack:GetChildren() do
    if v.Name == 'Grenade 2' and v:FindFirstChild('RemoteEvent') then
        v.Parent = plr.Character
        
        -- Generar posición aleatoria alrededor del personaje
        local characterPosition = plr.Character.HumanoidRootPart.Position
        local randomOffset = Vector3.new(
            math.random(-radius, radius), 
            math.random(-1, 2), -- Pequeño margen vertical
            math.random(-radius, radius)
        )
        local targetPosition = characterPosition + randomOffset

        -- Calcular LookVector desde el personaje hacia el punto objetivo
        local lookVector = (targetPosition - characterPosition).Unit
        
        -- Disparar evento remoto con el LookVector calculado
        v.RemoteEvent:FireServer(lookVector)
        v.Parent = plr.Backpack
    end
end
end)

window:Button("Lag Parts",function()
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local ReferencePart = Instance.new("Part", Workspace) -- Parte invisible como referencia para el Attachment
ReferencePart.Anchored = true
ReferencePart.CanCollide = false
ReferencePart.Transparency = 1

local Attachment1 = Instance.new("Attachment", ReferencePart) -- Attachment usado para AlignPosition

-- Función para encontrar el jugador más cercano
local function GetClosestPlayer(partPosition)
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - partPosition).Magnitude
            if distance < shortestDistance then
                closestPlayer = player.Character.HumanoidRootPart
                shortestDistance = distance
            end
        end
    end

    return closestPlayer
end

-- Modificar las partes existentes
local function ModifyPart(v)
    if v:IsA("Part") and v.Anchored == false and v.Parent:FindFirstChild("Humanoid") == nil and v.Parent:FindFirstChild("Head") == nil and v.Name ~= "Handle" then
        for _, child in pairs(v:GetChildren()) do
            if child:IsA("BodyAngularVelocity") or child:IsA("BodyForce") or child:IsA("BodyGyro") or child:IsA("BodyPosition") or child:IsA("BodyThrust") or child:IsA("BodyVelocity") or child:IsA("RocketPropulsion") then
                child:Destroy()
            end
        end
        if v:FindFirstChild("Attachment") then
            v:FindFirstChild("Attachment"):Destroy()
        end
        if v:FindFirstChild("AlignPosition") then
            v:FindFirstChild("AlignPosition"):Destroy()
        end

        -- Crear los elementos para lanzar la parte
        local Attachment2 = Instance.new("Attachment", v)
        local AlignPosition = Instance.new("AlignPosition", v)
        AlignPosition.Attachment0 = Attachment2
        AlignPosition.Attachment1 = Attachment1
        AlignPosition.MaxForce = 100000
        AlignPosition.MaxVelocity = 200
        AlignPosition.Responsiveness = 200
        AlignPosition.RigidityEnabled = false

        -- Mantener la parte disparada hacia el jugador más cercano
        RunService.Heartbeat:Connect(function()
            local closestPlayer = GetClosestPlayer(v.Position)
            if closestPlayer then
                ReferencePart.Position = closestPlayer.Position + Vector3.new(0, -5, 0)
            end
        end)

        -- Fling hacia abajo al colisionar
        v.Touched:Connect(function(hit)
            if hit.Parent:FindFirstChild("Humanoid") then
                local humanoid = hit.Parent:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.Sit = true
                    local flingVelocity = Instance.new("BodyVelocity", hit.Parent:FindFirstChild("HumanoidRootPart"))
                    flingVelocity.MaxForce = Vector3.new(1e6, 1e6, 1e6)
                    flingVelocity.Velocity = Vector3.new(0, -500, 0) -- Fling hacia abajo
                    game.Debris:AddItem(flingVelocity, 0.2) -- Eliminar después de 0.2 segundos
                end
            end
        end)
    end
end

-- Aplicar modificaciones a las partes existentes
for _, v in ipairs(Workspace:GetDescendants()) do
    ModifyPart(v)
end

-- Detectar nuevas partes añadidas
Workspace.DescendantAdded:Connect(function(v)
    ModifyPart(v)
end)
end)

window:Button("Inf Dash (any exec)",function()
local player = game.Players.LocalPlayer

local function setupCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")
    local huroot = character:WaitForChild("HumanoidRootPart")

    local dashanimation = Instance.new("Animation")
    dashanimation.AnimationId = "rbxassetid://6489881016"

    local function dash()
        local anim = humanoid:LoadAnimation(dashanimation)
        anim:Play()

        local bodyv = Instance.new("BodyVelocity", huroot)
        bodyv.MaxForce = Vector3.new(20000, 0, 20000)
        bodyv.Velocity = humanoid.MoveDirection * Vector3.new(90, 0, 90)

        if humanoid.MoveDirection == Vector3.new(0, 0, 0) then
            bodyv.Velocity = huroot.CFrame.LookVector * Vector3.new(90, 0, 90)
        end

        game:GetService("Debris"):AddItem(bodyv, 0.2)
    end

    game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.E then
            dash()
        end
    end)
end

-- Conectar cuando el personaje inicial ya existe
if player.Character then
    setupCharacter(player.Character)
end

-- Conectar para futuros spawns
player.CharacterAdded:Connect(setupCharacter)
end)

local Mouse = game.Players.LocalPlayer:GetMouse()
game:GetService("UserInputService").InputBegan:Connect(function(Input, IsTyping)
if IsTyping then return end
if Input.KeyCode == Enum.KeyCode.F1 then
local player = game.Players.LocalPlayer  -- Obtener el jugador local
local humanoid = game.Workspace[player.Name].Humanoid  -- Obtener el Humanoid del jugador local
humanoid.Health = 0  -- Establecer la salud del Humanoid a 0
end
end)

--Disables AutoJump
game.Players.LocalPlayer.AutoJumpEnabled = false

plr:GetMouse().KeyDown:Connect(function(key)
    if key == 'z' and tar and plr.Character then 
        for _,v in next,plr.Character:GetDescendants() do
            if v:IsA'Tool' and not v:FindFirstChild'ClientCD' and v:FindFirstChild'DamageRemote' and v:FindFirstChild'Cooldown' and tar and tar.Character and tar.Character:FindFirstChildOfClass'Humanoid' then
                AddCd(v,v.Cooldown.Value)
                local player = game.Players.LocalPlayer 
                Workspace[player.Name]:FindFirstChild(v.Name).Blade.HitSound:Play()
                rs.Stepped:Wait() --LOLLLL Fixed.
                v.DamageRemote:FireServer(tar.Character:FindFirstChildOfClass'Humanoid')          
            end
        end
    end
end)

window:Section(" Live Function")

window:Button("Users Using Script",function()
-- Llamar a la función de notificación para mostrar los jugadores conectados
local function notifyActiveSigmas(requestingPlayer)
    local activeSigmas = {}
    for _, sigmaUser in ipairs(sigmas) do
        local sigmaPlayer = findPlayerByName(sigmaUser)
        if sigmaPlayer then
            table.insert(activeSigmas, sigmaPlayer.Name)
        end
    end

    if #activeSigmas > 0 then
        notifyPlayer(requestingPlayer, "Usuarios activos", "Conectados: " .. table.concat(activeSigmas, ", "))
    else
        notifyPlayer(requestingPlayer, "Usuarios activos", "No hay usuarios de Sigma conectados.")
    end
end

-- Ejemplo de uso de la función
game:GetService("Players").PlayerAdded:Connect(function(player)
    -- Esperar un poco para que el jugador esté completamente cargado
    wait(2)
    -- Llamar a la función para notificar a un jugador en el momento que entra al juego
    notifyActiveSigmas(player)
end)

-- Llamada manual (puedes usar esto en cualquier otro lugar del script)
local requestingPlayer = game.Players:FindFirstChild("pedrood2") -- Ejemplo de jugador
if requestingPlayer then
    wait("0.5")
    notifyActiveSigmas(requestingPlayer) 
end
end)

-- Llama a la función para mostrar una notificación
showNotification("¡New Updates!", "¡Loop Kill With Anti-Hit!", 5) -- Título, texto, duración
